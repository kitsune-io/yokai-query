{"version":3,"sources":["../src/api.ts","../src/auth/token.ts","../src/api/client.ts","../src/store/client.ts","../src/store/defaults.ts","../src/utils/keys.ts","../src/utils/equality.ts","../src/utils/retry.ts","../src/storage/idb.ts","../src/auth/betterAuth.ts","../src/auth/simple.ts","../src/realtime/socket.ts","../src/realtime/sse.ts","../src/realtime/chat.ts","../src/realtime/webrtc.ts","../src/observability/devtools.ts","../src/observability/tracing.ts","../src/prefetch/scheduler.ts","../src/store/versioning.ts","../src/store/snapshot.ts","../src/mutations/offlineQueue.ts","../src/realtime/presence.ts","../src/realtime/readReceipts.ts","../src/simple/cache.ts","../src/simple/store.ts","../src/hooks/useQuery.ts","../src/hooks/useInfiniteQuery.ts","../src/hooks/useMutation.ts","../src/simple/hooks.ts"],"sourcesContent":["import { createFetch } from \"@better-fetch/fetch\";\nimport { getAuthToken } from \"./auth/token\";\n\nexport const api = createFetch({\n  baseURL: \"/api\",\n  throw: true,\n  auth: {\n    type: \"Bearer\",\n    token: () => getAuthToken(),\n  },\n  retry: {\n    type: \"linear\",\n    attempts: 3,\n    delay: 300,\n  },\n});\n","let authToken: string | undefined;\n\nexport const setAuthToken = (token?: string) => {\n  authToken = token;\n};\n\nexport const clearAuthToken = () => {\n  authToken = undefined;\n};\n\nexport const getAuthToken = () => authToken;\n","import { RetryOptions } from \"../types\";\nimport { getAuthToken } from \"../auth/token\";\n\nexport type ApiPlugin = {\n  onRequest?: (input: RequestInfo, init: RequestInit) => void;\n  onResponse?: (response: Response) => void;\n  onError?: (error: unknown) => void;\n};\n\nexport type ApiRetryRule = {\n  prefix: string;\n  retry: RetryOptions;\n};\n\nexport type ApiClientOptions = {\n  baseURL?: string;\n  getAuthToken?: () => string | undefined;\n  defaultRetry?: RetryOptions;\n  retryRules?: ApiRetryRule[];\n  plugins?: ApiPlugin[];\n};\n\nconst resolveRetry = (path: string, rules?: ApiRetryRule[]) => {\n  if (!rules) return undefined;\n  const matched = rules.find((rule) => path.startsWith(rule.prefix));\n  return matched?.retry;\n};\n\nconst sleep = (ms: number) =>\n  new Promise<void>((resolve) => setTimeout(resolve, ms));\n\nconst runWithRetry = async <T>(\n  fn: () => Promise<T>,\n  retryCfg?: RetryOptions\n): Promise<T> => {\n  const cfg = retryCfg ?? { attempts: 1 };\n  const attempts = Math.max(1, cfg.attempts ?? 1);\n  const retryOn = cfg.retryOn ?? (() => true);\n  const delayCfg = cfg.delay ?? 0;\n\n  let lastErr: unknown;\n\n  for (let i = 0; i < attempts; i += 1) {\n    try {\n      return await fn();\n    } catch (err) {\n      lastErr = err;\n      if (i === attempts - 1) break;\n      if (!retryOn(err, i + 1)) break;\n      const ms =\n        typeof delayCfg === \"function\" ? delayCfg(i + 1) : delayCfg;\n      if (ms > 0) await sleep(ms);\n    }\n  }\n\n  throw lastErr;\n};\n\nexport const createApiClient = (options: ApiClientOptions = {}) => {\n  const baseURL = options.baseURL ?? \"/api\";\n  const tokenFn = options.getAuthToken ?? getAuthToken;\n  const plugins = options.plugins ?? [];\n\n  const request = async <T = unknown>(\n    path: string,\n    init: RequestInit = {}\n  ): Promise<T> => {\n    const url = `${baseURL}${path}`;\n    const headers = new Headers(init.headers ?? {});\n    const token = tokenFn();\n    if (token) {\n      headers.set(\"Authorization\", `Bearer ${token}`);\n    }\n\n    const finalInit: RequestInit = { ...init, headers };\n    plugins.forEach((p) => p.onRequest?.(url, finalInit));\n\n    const retryCfg =\n      resolveRetry(path, options.retryRules) ?? options.defaultRetry;\n\n    return runWithRetry(async () => {\n      try {\n        const res = await fetch(url, finalInit);\n        plugins.forEach((p) => p.onResponse?.(res));\n        if (!res.ok) {\n          throw new Error(`HTTP ${res.status}`);\n        }\n        return (await res.json()) as T;\n      } catch (err) {\n        plugins.forEach((p) => p.onError?.(err));\n        throw err;\n      }\n    }, retryCfg);\n  };\n\n  return {\n    request,\n    get: <T = unknown>(path: string, init?: RequestInit) =>\n      request<T>(path, { ...init, method: \"GET\" }),\n    post: <T = unknown>(path: string, body?: unknown, init?: RequestInit) =>\n      request<T>(path, {\n        ...init,\n        method: \"POST\",\n        body: body !== undefined ? JSON.stringify(body) : undefined,\n        headers: { \"Content-Type\": \"application/json\", ...(init?.headers ?? {}) },\n      }),\n    put: <T = unknown>(path: string, body?: unknown, init?: RequestInit) =>\n      request<T>(path, {\n        ...init,\n        method: \"PUT\",\n        body: body !== undefined ? JSON.stringify(body) : undefined,\n        headers: { \"Content-Type\": \"application/json\", ...(init?.headers ?? {}) },\n      }),\n    patch: <T = unknown>(path: string, body?: unknown, init?: RequestInit) =>\n      request<T>(path, {\n        ...init,\n        method: \"PATCH\",\n        body: body !== undefined ? JSON.stringify(body) : undefined,\n        headers: { \"Content-Type\": \"application/json\", ...(init?.headers ?? {}) },\n      }),\n    delete: <T = unknown>(path: string, init?: RequestInit) =>\n      request<T>(path, { ...init, method: \"DELETE\" }),\n  };\n};\n","\r\nimport { create } from \"zustand\";\nimport {\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  MutationDefaultOptions,\n  MutateOptions,\n  QueryClientConfig,\n  QueryClientConfigUpdate,\n  QueryDefaultOptions,\n  QueryEntry,\n  QueryFetcher,\n  QueryKey,\n  QueryKeyHash,\n  QueryStore,\n  Metrics,\n} from \"../types\";\nimport {\n  DEFAULT_CACHE_TIME,\n  DEFAULT_STALE_TIME,\n  createMetrics,\n  defaultConfig,\n} from \"./defaults\";\nimport { hashKey, keyToString } from \"../utils/keys\";\nimport { replaceEqualDeep } from \"../utils/equality\";\nimport { isAbortError, runWithRetry } from \"../utils/retry\";\nimport { idbGet, idbSet } from \"../storage/idb\";\n\nexport function createQueryClient(userConfig?: QueryClientConfigUpdate) {\n  const { multiTabSync: multiTabSyncOverride, ...userOverrides } =\n    userConfig ?? {};\n  const cfg: QueryClientConfig = {\n    ...defaultConfig,\n    ...userOverrides,\n    persistence: {\n      ...defaultConfig.persistence,\n      ...(userOverrides.persistence ?? {}),\n    },\n    retry: {\n      ...defaultConfig.retry,\n      ...(userOverrides.retry ?? {}),\n    },\n    multiTabSync: {\n      ...defaultConfig.multiTabSync,\n      ...(multiTabSyncOverride ?? {}),\n    },\n    devtools: {\n      ...defaultConfig.devtools,\n      ...(userOverrides.devtools ?? {}),\n    },\n  };\n\n  const fetchers = new Map<QueryKeyHash, QueryFetcher<unknown>>();\n  const infiniteFetchers = new Map<\n    QueryKeyHash,\n    (ctx: { pageParam: unknown; signal?: AbortSignal }) => Promise<unknown>\n  >();\n  const keyMap = new Map<QueryKeyHash, QueryKey>();\n  const resolveKey = (hashedKey: QueryKeyHash): QueryKey =>\n    keyMap.get(hashedKey) ?? hashedKey;\n\n  const pollers = new Map<QueryKeyHash, { timer: number; interval: number }>();\n\n  const selectMemo = new Map<\n    QueryKeyHash,\n    { selectRef: Function; inputRef: unknown; output: unknown }\n  >();\n\n  const tagIndex = new Map<string, Set<QueryKeyHash>>();\n\n  const aborters = new Map<QueryKeyHash, AbortController>();\n  const mutationAborters = new Map<QueryKeyHash, AbortController>();\n  const observers = new Map<QueryKeyHash, number>();\n  const inFlightMeta = new Map<\n    QueryKeyHash,\n    { direction?: \"forward\" | \"backward\" | \"init\" }\n  >();\n\n  let batchDepth = 0;\n  let pendingQueries: Record<QueryKeyHash, QueryEntry> | null = null;\n  let flushRequested = false;\n\n  let flushTimer: number | null = null;\n\n  const isBrowser = typeof window !== \"undefined\";\n  const instanceId = Math.random().toString(36).slice(2);\n  const channel =\n    isBrowser &&\n    cfg.multiTabSync.enabled &&\n    typeof BroadcastChannel !== \"undefined\"\n      ? new BroadcastChannel(cfg.multiTabSync.channelName)\n      : null;\n  let suppressBroadcast = false;\n  const broadcast = (message: { type: string; payload?: unknown }) => {\n    if (!channel || suppressBroadcast) return;\n    channel.postMessage({ ...message, sourceId: instanceId });\n  };\n  const getQueryDefaultOptions = (\n    key: QueryKey,\n    config: QueryClientConfig\n  ): QueryDefaultOptions => {\n    const keyStr = keyToString(key);\n    const defaults = config.queryDefaults ?? [];\n    let merged: QueryDefaultOptions = {};\n    defaults.forEach((entry) => {\n      if (keyStr.startsWith(entry.prefix)) {\n        merged = { ...merged, ...entry.options };\n      }\n    });\n    return merged;\n  };\n  const getMutationDefaultOptions = (\n    key: QueryKey | undefined,\n    config: QueryClientConfig\n  ): MutationDefaultOptions => {\n    if (!key) return {};\n    const keyStr = keyToString(key);\n    const defaults = config.mutationDefaults ?? [];\n    let merged: MutationDefaultOptions = {};\n    defaults.forEach((entry) => {\n      if (keyStr.startsWith(entry.key)) {\n        merged = { ...merged, ...entry.options };\n      }\n    });\n    return merged;\n  };\n  const applyStructuralSharing = <T>(prev: T | undefined, next: T): T => {\n    if (!cfg.structuralSharing) return next;\n    if (prev === undefined) return next;\n    if (next === undefined) return next;\n    return replaceEqualDeep(prev, next);\n  };\n\n  const store = create<QueryStore>((set, get) => ({\n    config: cfg,\n\n    queries: {},\n    inFlight: {},\n    mutations: {},\n\n    metrics: createMetrics(),\n\n    dehydrate() {\n      return serializeQueries(get().queries);\n    },\n\n    hydrate(data) {\n      set({\n        queries: Object.fromEntries(\n          Object.entries(data).map(([k, q]) => [\n            k,\n            {\n              ...q,\n              staleTime: q.staleTime ?? DEFAULT_STALE_TIME,\n              cacheTime: q.cacheTime ?? DEFAULT_CACHE_TIME,\n              tags: q.tags ?? [],\n              retry: q.retry,\n              keyString: q.keyString ?? k,\n            } satisfies QueryEntry,\n          ])\n        ),\n      });\n\n      tagIndex.clear();\n      selectMemo.clear();\n      Object.entries(get().queries).forEach(([k, q]) => {\n        keyMap.set(k, k);\n        (q.tags ?? []).forEach((t) => {\n          if (!tagIndex.has(t)) tagIndex.set(t, new Set());\n          tagIndex.get(t)!.add(k);\n        });\n      });\n\n      if (isBrowser) {\n        Object.entries(get().queries).forEach(([k, q]) => {\n          ensurePoller(k, q.refetchInterval);\n        });\n      }\n\n      devtoolsEmit(\"hydrate\", { keys: Object.keys(get().queries) });\n    },\n\r\n    async fetchQuery<T>(key: QueryKey, options: FetchQueryOptions<T>) {\n      const hashedKey = hashKey(key);\n      keyMap.set(hashedKey, key);\n      const defaults = getQueryDefaultOptions(key, get().config);\n      const {\n        suspense: _s,\n        throwOnError: _t,\n        keepPreviousData: _k,\n        initialData: _i,\n        placeholderData: _p,\n        ...fetchDefaults\n      } = defaults;\n      const mergedOptions: FetchQueryOptions<T> = {\n        ...fetchDefaults,\n        ...options,\n        retry: options.retry ?? defaults.retry,\n        tags: options.tags ?? defaults.tags,\n        refetchInterval: options.refetchInterval ?? defaults.refetchInterval,\n        abortOnNewFetch: options.abortOnNewFetch ?? defaults.abortOnNewFetch,\n        background: options.background ?? defaults.background,\n        skipStaleWhileRevalidate: options.skipStaleWhileRevalidate ?? false,\n        staleTime: options.staleTime ?? defaults.staleTime,\n        cacheTime: options.cacheTime ?? defaults.cacheTime,\n      };\n      const {\n        fetcher,\n        staleTime = DEFAULT_STALE_TIME,\n        cacheTime = DEFAULT_CACHE_TIME,\n        background = false,\n        skipStaleWhileRevalidate = false,\n        meta,\n        refetchInterval,\n        tags,\n        retry,\n        abortOnNewFetch = true,\n        onSuccess,\n        onError,\n        onSettled,\n      } = mergedOptions;\n\n      fetchers.set(hashedKey, fetcher as QueryFetcher<unknown>);\n\n      setEntry(hashedKey, {\n        staleTime,\n        cacheTime,\n        fetcher,\n        refetchInterval,\n        tags: tags ?? get().queries[hashedKey]?.tags ?? [],\n        retry: retry ?? get().queries[hashedKey]?.retry,\n        meta: meta ?? get().queries[hashedKey]?.meta,\n        keyString: get().queries[hashedKey]?.keyString ?? keyToString(key),\n      });\n\n      syncTagsIndex(hashedKey, tags);\n\n      ensurePoller(hashedKey, refetchInterval);\n\n      const state = get();\n      const entry = state.queries[hashedKey];\n      const now = Date.now();\n\n      const isStale =\n        !entry?.fetchedAt ||\n        now - entry.fetchedAt > (entry?.staleTime ?? staleTime);\n\n      if (entry?.data !== undefined && !isStale) {\n        bump({ hits: 1 });\n        touch(hashedKey);\n        debugLog(\"hit\", hashedKey);\n        devtoolsEmit(\"hit\", { key: hashedKey });\n        return entry.data as T;\n      }\n\n      if (state.inFlight[hashedKey]) {\n        bump({ dedupes: 1 });\n        debugLog(\"dedupe\", hashedKey);\n        devtoolsEmit(\"dedupe\", { key: hashedKey });\n        return state.inFlight[hashedKey] as Promise<T>;\n      }\n\n      const shouldBackground =\n        entry?.data !== undefined &&\n        isStale &&\n        !skipStaleWhileRevalidate &&\n        (background || get().config.staleWhileRevalidate);\n      if (shouldBackground) {\n        if (get().inFlight[hashedKey]) {\n          bump({ dedupes: 1, backgroundFetches: 1 });\n          debugLog(\"dedupe\", hashedKey);\n          devtoolsEmit(\"dedupe\", { key: hashedKey });\n          return entry.data as T;\n        }\n        bump({ hits: 1, backgroundFetches: 1 });\n        debugLog(\"stale-hit+bg\", hashedKey);\n        devtoolsEmit(\"stale-hit+bg\", { key: hashedKey });\n\n        const originalKey = resolveKey(hashedKey);\n        get()\n          .fetchQuery(originalKey, {\n            ...mergedOptions,\n            background: false,\n            skipStaleWhileRevalidate: true,\n          })\n          .catch(() => {});\n        touch(hashedKey);\n        return entry.data as T;\n      }\n\n      if (abortOnNewFetch) {\n        get().abort(hashedKey);\n      }\n\n      bump({ misses: 1, fetches: 1 });\n      debugLog(\"miss(fetch)\", hashedKey);\n      devtoolsEmit(\"miss(fetch)\", { key: hashedKey });\n\n      const controller = isBrowser ? new AbortController() : undefined;\n      if (controller) aborters.set(hashedKey, controller);\n\n      const promise = (async () => {\n        try {\n          const data = await runWithRetry<T>(\n            async (attemptIndex) => {\n              if (controller?.signal?.aborted) {\n                throw (\n                  controller.signal.reason ??\n                  new DOMException(\"Aborted\", \"AbortError\")\n                );\n              }\n\n              const f = fetcher as any;\n              const maybePromise =\n                typeof f === \"function\" && f.length >= 1\n                  ? (f({ signal: controller?.signal }) as Promise<T>)\n                  : (f() as Promise<T>);\n\n              return await maybePromise;\n            },\n            retry ?? entry?.retry ?? get().config.retry,\n            (n) => bump({ retries: n }),\n            (attempt, attempts) => devtoolsEmit(\"retry\", { attempt, attempts })\n          );\n\n          setEntry(hashedKey, {\n            data,\n            error: undefined,\n            fetchedAt: Date.now(),\n            accessedAt: Date.now(),\n            staleTime,\n            cacheTime,\n            refetchInterval,\n            fetcher,\n            tags: tags ?? get().queries[hashedKey]?.tags ?? [],\n            retry: retry ?? get().queries[hashedKey]?.retry,\n            meta: meta ?? get().queries[hashedKey]?.meta,\n            keyString: get().queries[hashedKey]?.keyString ?? keyToString(key),\n          });\n\n          evictLRUIfNeeded();\n\n          scheduleFlush();\n          devtoolsEmit(\"fetch:success\", { key: hashedKey });\n          onSuccess?.(data);\n          onSettled?.(data, undefined);\n          return data;\n        } catch (error) {\n          if (isAbortError(error)) {\n            bump({ aborts: 1 });\n            setEntry(hashedKey, {\n              error,\n              fetchedAt: Date.now(),\n              fetcher,\n              lastAbortAt: Date.now(),\n              meta: meta ?? get().queries[hashedKey]?.meta,\n              keyString:\n                get().queries[hashedKey]?.keyString ?? keyToString(key),\n            });\n            scheduleFlush();\n            devtoolsEmit(\"fetch:abort\", { key: hashedKey });\n            throw error;\n          }\n\n          bump({ errors: 1 });\n          setEntry(hashedKey, {\n            error,\n            fetchedAt: Date.now(),\n            fetcher,\n            meta: meta ?? get().queries[hashedKey]?.meta,\n            keyString: get().queries[hashedKey]?.keyString ?? keyToString(key),\n          });\n          scheduleFlush();\n          devtoolsEmit(\"fetch:error\", { key: hashedKey });\n          onError?.(error);\n          onSettled?.(undefined, error);\n          throw error;\n        } finally {\n          set((s) => {\n            const next = { ...s.inFlight };\n            delete next[hashedKey];\n            return { inFlight: next };\n          });\n\n          if (controller && aborters.get(hashedKey) === controller) {\n            aborters.delete(hashedKey);\n          }\n        }\n      })();\n\n      set((s) => ({ inFlight: { ...s.inFlight, [hashedKey]: promise } }));\n      return promise;\n    },\n\r\n    async fetchInfiniteQuery<TPage, TParam>(\n      key: QueryKey,\n      options: FetchInfiniteQueryOptions<TPage, TParam>\n    ) {\n      const hashedKey = hashKey(key);\n      keyMap.set(hashedKey, key);\n      const defaults = getQueryDefaultOptions(key, get().config);\n      const {\n        suspense: _s,\n        throwOnError: _t,\n        keepPreviousData: _k,\n        initialData: _i,\n        placeholderData: _p,\n        ...fetchDefaults\n      } = defaults;\n      const mergedOptions: FetchInfiniteQueryOptions<TPage, TParam> = {\n        ...fetchDefaults,\n        ...options,\n        retry: options.retry ?? defaults.retry,\n        tags: options.tags ?? defaults.tags,\n        refetchInterval: options.refetchInterval ?? defaults.refetchInterval,\n        abortOnNewFetch: options.abortOnNewFetch ?? defaults.abortOnNewFetch,\n        background: options.background ?? defaults.background,\n        staleTime: options.staleTime ?? defaults.staleTime,\n        cacheTime: options.cacheTime ?? defaults.cacheTime,\n      };\n\n      const {\n        fetcher,\n        pageParam,\n        direction = \"init\",\n        staleTime = DEFAULT_STALE_TIME,\n        cacheTime = DEFAULT_CACHE_TIME,\n        background = false,\n        meta,\n        refetchInterval,\n        tags,\n        retry,\n        abortOnNewFetch = true,\n        onSuccess,\n        onError,\n        onSettled,\n      } = mergedOptions;\n\n      infiniteFetchers.set(\n        hashedKey,\n        fetcher as (ctx: { pageParam: unknown; signal?: AbortSignal }) =>\n          Promise<unknown>\n      );\n\n      setEntry(hashedKey, {\n        staleTime,\n        cacheTime,\n        refetchInterval,\n        tags: tags ?? get().queries[hashedKey]?.tags ?? [],\n        retry: retry ?? get().queries[hashedKey]?.retry,\n        meta: meta ?? get().queries[hashedKey]?.meta,\n        keyString: get().queries[hashedKey]?.keyString ?? keyToString(key),\n      });\n\n      syncTagsIndex(hashedKey, tags);\n      ensurePoller(hashedKey, refetchInterval);\n\n      const state = get();\n      const entry = state.queries[hashedKey];\n      const now = Date.now();\n      const isStale =\n        !entry?.fetchedAt ||\n        now - entry.fetchedAt > (entry?.staleTime ?? staleTime);\n\n      const current = entry?.data as\n        | InfiniteData<TPage, TParam>\n        | undefined;\n\n      if (direction === \"init\" && current && !isStale && !background) {\n        bump({ hits: 1 });\n        touch(hashedKey);\n        debugLog(\"hit\", hashedKey);\n        devtoolsEmit(\"hit\", { key: hashedKey });\n        return current;\n      }\n\n      if (state.inFlight[hashedKey]) {\n        bump({ dedupes: 1 });\n        debugLog(\"dedupe\", hashedKey);\n        devtoolsEmit(\"dedupe\", { key: hashedKey });\n        return state.inFlight[hashedKey] as Promise<\n          InfiniteData<TPage, TParam>\n        >;\n      }\n\n      if (\n        direction === \"init\" &&\n        current &&\n        isStale &&\n        (background || get().config.staleWhileRevalidate)\n      ) {\n        bump({ hits: 1, backgroundFetches: 1 });\n        debugLog(\"stale-hit+bg\", hashedKey);\n        devtoolsEmit(\"stale-hit+bg\", { key: hashedKey });\n        const originalKey = resolveKey(hashedKey);\n        get()\n          .refetchInfiniteQuery<TPage, TParam>(originalKey)\n          .catch(() => {});\n        touch(hashedKey);\n        return current;\n      }\n\n      if (abortOnNewFetch) {\n        get().abort(hashedKey);\n      }\n\n      bump({ misses: 1, fetches: 1 });\n      debugLog(\"miss(fetch)\", hashedKey);\n      devtoolsEmit(\"miss(fetch)\", { key: hashedKey });\n\n      const controller = isBrowser ? new AbortController() : undefined;\n      if (controller) aborters.set(hashedKey, controller);\n      inFlightMeta.set(hashedKey, { direction });\n\n      const promise = (async () => {\n        try {\n          const page = await runWithRetry<TPage>(\n            async () => {\n              if (controller?.signal?.aborted) {\n                throw (\n                  controller.signal.reason ??\n                  new DOMException(\"Aborted\", \"AbortError\")\n                );\n              }\n              return await fetcher({ pageParam, signal: controller?.signal });\n            },\n            retry ?? entry?.retry ?? get().config.retry,\n            (n) => bump({ retries: n }),\n            (attempt, attempts) => devtoolsEmit(\"retry\", { attempt, attempts })\n          );\n\n          let next: InfiniteData<TPage, TParam>;\n          if (!current) {\n            next = { pages: [page], pageParams: [pageParam] };\n          } else if (direction === \"backward\") {\n            next = {\n              pages: [page, ...current.pages],\n              pageParams: [pageParam, ...current.pageParams],\n            };\n          } else {\n            next = {\n              pages: [...current.pages, page],\n              pageParams: [...current.pageParams, pageParam],\n            };\n          }\n\n          setEntry(hashedKey, {\n            data: next,\n            error: undefined,\n            fetchedAt: Date.now(),\n            accessedAt: Date.now(),\n            staleTime,\n            cacheTime,\n            refetchInterval,\n            tags: tags ?? get().queries[hashedKey]?.tags ?? [],\n            retry: retry ?? get().queries[hashedKey]?.retry,\n            meta: meta ?? get().queries[hashedKey]?.meta,\n            keyString: get().queries[hashedKey]?.keyString ?? keyToString(key),\n          });\n\n          evictLRUIfNeeded();\n          scheduleFlush();\n          devtoolsEmit(\"fetch:success\", { key: hashedKey });\n          onSuccess?.(next);\n          onSettled?.(next, undefined);\n          return next;\n        } catch (error) {\n          if (isAbortError(error)) {\n            bump({ aborts: 1 });\n            setEntry(hashedKey, {\n              error,\n              fetchedAt: Date.now(),\n              lastAbortAt: Date.now(),\n              meta: meta ?? get().queries[hashedKey]?.meta,\n              keyString:\n                get().queries[hashedKey]?.keyString ?? keyToString(key),\n            });\n            scheduleFlush();\n            devtoolsEmit(\"fetch:abort\", { key: hashedKey });\n            throw error;\n          }\n\n          bump({ errors: 1 });\n          setEntry(hashedKey, {\n            error,\n            fetchedAt: Date.now(),\n            meta: meta ?? get().queries[hashedKey]?.meta,\n            keyString: get().queries[hashedKey]?.keyString ?? keyToString(key),\n          });\n          scheduleFlush();\n          devtoolsEmit(\"fetch:error\", { key: hashedKey });\n          onError?.(error);\n          onSettled?.(undefined, error);\n          throw error;\n        } finally {\n          set((s) => {\n            const next = { ...s.inFlight };\n            delete next[hashedKey];\n            return { inFlight: next };\n          });\n          inFlightMeta.delete(hashedKey);\n          if (controller && aborters.get(hashedKey) === controller) {\n            aborters.delete(hashedKey);\n          }\n        }\n      })();\n\n      set((s) => ({ inFlight: { ...s.inFlight, [hashedKey]: promise } }));\n      return promise;\n    },\n\n    async refetchInfiniteQuery<TPage, TParam>(key: QueryKey) {\n      const hashedKey = hashKey(key);\n      const entry = get().queries[hashedKey];\n      const fetcher = infiniteFetchers.get(hashedKey) as\n        | ((ctx: { pageParam: TParam; signal?: AbortSignal }) => Promise<TPage>)\n        | undefined;\n      const data = entry?.data as InfiniteData<TPage, TParam> | undefined;\n      if (!entry || !fetcher || !data) return undefined;\n      if (get().inFlight[hashedKey]) {\n        return get().inFlight[hashedKey] as Promise<\n          InfiniteData<TPage, TParam>\n        >;\n      }\n\n      const controller = isBrowser ? new AbortController() : undefined;\n      if (controller) aborters.set(hashedKey, controller);\n      inFlightMeta.set(hashedKey, { direction: \"init\" });\n\n      const promise = (async () => {\n        try {\n          const pages: TPage[] = [];\n          for (let i = 0; i < data.pageParams.length; i += 1) {\n            const pageParam = data.pageParams[i];\n            const page = await runWithRetry<TPage>(\n              async (_attemptIndex): Promise<TPage> => {\n                if (controller?.signal?.aborted) {\n                  throw (\n                    controller.signal.reason ??\n                    new DOMException(\"Aborted\", \"AbortError\")\n                  );\n                }\n                const result = await fetcher({\n                  pageParam,\n                  signal: controller?.signal,\n                });\n                return result as TPage;\n              },\n              entry.retry ?? get().config.retry,\n              (n) => bump({ retries: n }),\n              (attempt, attempts) => devtoolsEmit(\"retry\", { attempt, attempts })\n            );\n            pages.push(page);\n          }\n\n          const next: InfiniteData<TPage, TParam> = {\n            pages,\n            pageParams: data.pageParams,\n          };\n\n          setEntry(hashedKey, {\n            data: next,\n            error: undefined,\n            fetchedAt: Date.now(),\n            accessedAt: Date.now(),\n          });\n          scheduleFlush();\n          devtoolsEmit(\"fetch:success\", { key: hashedKey });\n          return next;\n        } catch (error) {\n          if (isAbortError(error)) {\n            bump({ aborts: 1 });\n            setEntry(hashedKey, {\n              error,\n              fetchedAt: Date.now(),\n              lastAbortAt: Date.now(),\n            });\n            scheduleFlush();\n            devtoolsEmit(\"fetch:abort\", { key: hashedKey });\n            throw error;\n          }\n\n          bump({ errors: 1 });\n          setEntry(hashedKey, { error, fetchedAt: Date.now() });\n          scheduleFlush();\n          devtoolsEmit(\"fetch:error\", { key: hashedKey });\n          throw error;\n        } finally {\n          set((s) => {\n            const next = { ...s.inFlight };\n            delete next[hashedKey];\n            return { inFlight: next };\n          });\n          inFlightMeta.delete(hashedKey);\n          if (controller && aborters.get(hashedKey) === controller) {\n            aborters.delete(hashedKey);\n          }\n        }\n      })();\n\n      set((s) => ({ inFlight: { ...s.inFlight, [hashedKey]: promise } }));\n      return promise;\n    },\n\n    async prefetchQuery<T>(key: QueryKey, options: FetchQueryOptions<T>) {\n      const hashedKey = hashKey(key);\n      bump({ prefetched: 1 });\n      devtoolsEmit(\"prefetch\", { key: hashedKey });\n      await get().fetchQuery<T>(key, { ...options, background: false });\n    },\n\n    invalidate(key) {\n      const hashedKey = hashKey(key);\n      bump({ invalidations: 1 });\n\n      get().abort(hashedKey);\n      withDraft(\n        (draft) => {\n          if (!draft[hashedKey]) return;\n          draft[hashedKey] = {\n            ...draft[hashedKey],\n            fetchedAt: 0,\n            error: undefined,\n          };\n        },\n        false\n      );\n      scheduleFlush();\n      debugLog(\"invalidate\", hashedKey);\n      devtoolsEmit(\"invalidate\", { key: hashedKey });\n      broadcast({ type: \"invalidate\", payload: { key: hashedKey } });\n    },\n\n    invalidateByPrefix(prefix) {\n      bump({ invalidations: 1 });\n\n      const keys = Object.keys(get().queries).filter((k) => {\n        const original = keyMap.get(k) ?? k;\n        const keyString =\n          get().queries[k]?.keyString ?? keyToString(original as QueryKey);\n        return keyString.startsWith(prefix);\n      });\n      keys.forEach((k) => get().abort(k));\n      withDraft(\n        (draft) => {\n          Object.keys(draft).forEach((k) => {\n            const original = keyMap.get(k) ?? k;\n            const keyString =\n              draft[k]?.keyString ?? keyToString(original as QueryKey);\n            if (!keyString.startsWith(prefix)) return;\n            draft[k] = {\n              ...draft[k],\n              fetchedAt: 0,\n              error: undefined,\n            };\n          });\n        },\n        false\n      );\n      scheduleFlush();\n      debugLog(\"invalidateByPrefix\", prefix);\n      devtoolsEmit(\"invalidateByPrefix\", { prefix });\n      broadcast({ type: \"invalidateByPrefix\", payload: { prefix } });\n    },\n\n    invalidateTags(tags) {\n      bump({ invalidations: 1 });\n      const list = Array.isArray(tags) ? tags : [tags];\n\n      const keysToInvalidate = new Set<QueryKeyHash>();\n      list.forEach((t) => {\n        const setKeys = tagIndex.get(t);\n        if (!setKeys) return;\n        setKeys.forEach((k) => keysToInvalidate.add(k));\n      });\n\n      get().batch(() => {\n        keysToInvalidate.forEach((k) => get().invalidate(k));\n      });\n\n      debugLog(\"invalidateTags\", list);\n      devtoolsEmit(\"invalidateTags\", {\n        tags: list,\n        keys: Array.from(keysToInvalidate),\n      });\n      broadcast({ type: \"invalidateTags\", payload: { tags: list } });\n    },\n\n    cancelByTags(tags) {\n      const list = Array.isArray(tags) ? tags : [tags];\n      const keysToCancel = new Set<QueryKeyHash>();\n      list.forEach((t) => {\n        const setKeys = tagIndex.get(t);\n        if (!setKeys) return;\n        setKeys.forEach((k) => keysToCancel.add(k));\n      });\n      keysToCancel.forEach((k) => get().abort(k));\n      devtoolsEmit(\"cancelTags\", {\n        tags: list,\n        keys: Array.from(keysToCancel),\n      });\n    },\n\n    abort(key) {\n      const hashedKey = hashKey(key);\n      const controller = aborters.get(hashedKey);\n      if (!controller) return;\n      try {\n        controller.abort();\n      } catch {}\n      aborters.delete(hashedKey);\n      devtoolsEmit(\"abort\", { key: hashedKey });\n    },\n\n    cancelMutation(key) {\n      const hashedKey = hashKey(key);\n      const controller = mutationAborters.get(hashedKey);\n      if (!controller) return;\n      try {\n        controller.abort();\n      } catch {}\n      mutationAborters.delete(hashedKey);\n      devtoolsEmit(\"mutation:abort\", { key: hashedKey });\n    },\n\n    batch(fn) {\n      batchDepth += 1;\n      try {\n        fn();\n      } finally {\n        batchDepth -= 1;\n        if (batchDepth === 0 && pendingQueries) {\n          const next = pendingQueries;\n          pendingQueries = null;\n          set({ queries: next });\n          if (flushRequested) {\n            flushRequested = false;\n            scheduleFlush();\n          }\n          devtoolsEmit(\"batch:flush\", {});\n        }\n      }\n    },\n\n    gc() {\n      const now = Date.now();\n      let evicted = 0;\n\n      withDraft((draft) => {\n        Object.entries(draft).forEach(([k, q]) => {\n          if (!q.fetchedAt) return;\n          if (now - q.fetchedAt > q.cacheTime) {\n            get().abort(k);\n            ensurePoller(k, undefined);\n\n            removeKeyFromAllTags(k);\n\n            delete draft[k];\n            evicted += 1;\n          }\n        });\n      });\n\n      if (evicted > 0) {\n        bump({ gcEvictions: evicted });\n        scheduleFlush();\n        debugLog(\"gc evicted\", evicted);\n        devtoolsEmit(\"gc\", { evicted });\n      }\n    },\n\r\n    async mutate<TVars, TResult>(opts: MutateOptions<TVars, TResult>) {\n      bump({ mutations: 1 });\n      devtoolsEmit(\"mutate:start\", {});\n\n      const defaults = getMutationDefaultOptions(opts.mutationKey, get().config);\n      const mergedOptions: MutateOptions<TVars, TResult> = {\n        ...defaults,\n        ...opts,\n        retry: opts.retry ?? defaults.retry,\n        abortOnNewMutation:\n          opts.abortOnNewMutation ?? defaults.abortOnNewMutation,\n        invalidateKeys: opts.invalidateKeys ?? defaults.invalidateKeys,\n        invalidatePrefixes:\n          opts.invalidatePrefixes ?? defaults.invalidatePrefixes,\n        invalidateTags: opts.invalidateTags ?? defaults.invalidateTags,\n        optimistic: opts.optimistic ?? defaults.optimistic,\n        updateCache: opts.updateCache ?? defaults.updateCache,\n      } as MutateOptions<TVars, TResult>;\n\n      const {\n        mutationFn,\n        variables,\n        optimistic,\n        updateCache,\n        invalidateKeys,\n        invalidatePrefixes,\n        invalidateTags,\n        onSuccess,\n        onError,\n        retry,\n        abortOnNewMutation = true,\n      } = mergedOptions;\n\n      const mutationKey = mergedOptions.mutationKey ?? \"__mutation__\";\n      const hashedKey = hashKey(mutationKey);\n\n      if (abortOnNewMutation) {\n        get().cancelMutation(hashedKey);\n      }\n\n      const controller = isBrowser ? new AbortController() : undefined;\n      if (controller) mutationAborters.set(hashedKey, controller);\n\n      set((s) => ({\n        mutations: {\n          ...s.mutations,\n          [hashedKey]: {\n            status: \"loading\",\n            data: s.mutations[hashedKey]?.data,\n            error: undefined,\n            variables,\n            updatedAt: Date.now(),\n          },\n        },\n      }));\n\n      const snapshots = new Map<QueryKeyHash, unknown>();\n\n      if (optimistic && optimistic.length > 0) {\n        bump({ optimisticApplied: 1 });\n\n        get().batch(() => {\n          optimistic.forEach(({ key, update }) => {\n            const k = hashKey(key);\n            const prev = get().queries[k]?.data;\n            snapshots.set(k, prev);\n\n            setEntry(k, {\n              data: update(prev),\n              accessedAt: Date.now(),\n            });\n          });\n        });\n\n        scheduleFlush();\n        debugLog(\n          \"optimistic applied\",\n          optimistic.map((o) => o.key)\n        );\n        devtoolsEmit(\"mutate:optimistic\", {\n          keys: optimistic.map((o) => o.key),\n        });\n      }\n\n      const promise = (async () => {\n        try {\n          const result = await runWithRetry<TResult>(\n            async () => mutationFn(variables, { signal: controller?.signal }),\n            retry ?? get().config.retry,\n            (n) => bump({ retries: n }),\n            (attempt, attempts) => devtoolsEmit(\"retry\", { attempt, attempts })\n          );\n\n          if (updateCache && updateCache.length > 0) {\n            get().batch(() => {\n              updateCache.forEach(({ key, update }) => {\n                const k = hashKey(key);\n                const prev = get().queries[k]?.data;\n                setEntry(k, {\n                  data: update(prev, result),\n                  fetchedAt: Date.now(),\n                  accessedAt: Date.now(),\n                });\n              });\n            });\n          }\n\n          if (\n            (invalidateKeys && invalidateKeys.length) ||\n            (invalidatePrefixes && invalidatePrefixes.length) ||\n            (invalidateTags && invalidateTags.length)\n          ) {\n            get().batch(() => {\n              invalidateKeys?.forEach((k) => get().invalidate(k));\n              invalidatePrefixes?.forEach((p) => get().invalidateByPrefix(p));\n              if (invalidateTags?.length) get().invalidateTags(invalidateTags);\n            });\n          }\n\n          scheduleFlush();\n          onSuccess?.(result, variables);\n          devtoolsEmit(\"mutate:success\", {});\n          set((s) => ({\n            mutations: {\n              ...s.mutations,\n              [hashedKey]: {\n                status: \"success\",\n                data: result,\n                error: undefined,\n                variables,\n                updatedAt: Date.now(),\n              },\n            },\n          }));\n          return result;\n        } catch (error) {\n          if (optimistic && optimistic.length > 0) {\n            bump({ optimisticRolledBack: 1 });\n\n            get().batch(() => {\n              optimistic.forEach(({ key }) => {\n                const k = hashKey(key);\n                const prev = snapshots.get(k);\n                setEntry(k, { data: prev, accessedAt: Date.now() });\n              });\n            });\n\n            scheduleFlush();\n            debugLog(\"optimistic rollback\");\n            devtoolsEmit(\"mutate:rollback\", {\n              keys: optimistic.map((o) => o.key),\n            });\n          }\n\n          onError?.(error, variables);\n          devtoolsEmit(\"mutate:error\", {});\n          set((s) => ({\n            mutations: {\n              ...s.mutations,\n              [hashedKey]: {\n                status: \"error\",\n                data: s.mutations[hashedKey]?.data,\n                error,\n                variables,\n                updatedAt: Date.now(),\n              },\n            },\n          }));\n          throw error;\n        } finally {\n          if (controller && mutationAborters.get(hashedKey) === controller) {\n            mutationAborters.delete(hashedKey);\n          }\n        }\n      })();\n\n      set((s) => ({\n        mutations: {\n          ...s.mutations,\n          [hashedKey]: {\n            status: \"loading\",\n            data: s.mutations[hashedKey]?.data,\n            error: undefined,\n            variables,\n            promise,\n            updatedAt: Date.now(),\n          },\n        },\n      }));\n\n      return promise;\n    },\n\n    setDebug(debug) {\n      set((s) => ({ config: { ...s.config, debug } }));\n      devtoolsEmit(\"config:debug\", { debug });\n    },\n\n    setConfig(partial) {\n      set((s) => ({\n        config: {\n          ...s.config,\n          ...partial,\n          persistence: {\n            ...s.config.persistence,\n            ...(partial.persistence ?? {}),\n          },\n          retry: {\n            ...s.config.retry,\n            ...(partial.retry ?? {}),\n          },\n          multiTabSync: {\n            ...s.config.multiTabSync,\n            ...(partial.multiTabSync ?? {}),\n          },\n          devtools: {\n            ...s.config.devtools,\n            ...(partial.devtools ?? {}),\n          },\n        },\n      }));\n      devtoolsEmit(\"config:set\", { partial });\n    },\n\n    getMutation(key) {\n      const hashedKey = hashKey(key);\n      return get().mutations[hashedKey];\n    },\n\n    setQueryData(key, data, options) {\n      const hashedKey = hashKey(key);\n      keyMap.set(hashedKey, key);\n      setEntry(hashedKey, {\n        data,\n        error: undefined,\n        fetchedAt: options?.fetchedAt ?? Date.now(),\n        accessedAt: Date.now(),\n        staleTime:\n          options?.staleTime ??\n          get().queries[hashedKey]?.staleTime ??\n          DEFAULT_STALE_TIME,\n        cacheTime:\n          options?.cacheTime ??\n          get().queries[hashedKey]?.cacheTime ??\n          DEFAULT_CACHE_TIME,\n        refetchInterval:\n          options?.refetchInterval ?? get().queries[hashedKey]?.refetchInterval,\n        tags: options?.tags ?? get().queries[hashedKey]?.tags ?? [],\n        retry: options?.retry ?? get().queries[hashedKey]?.retry,\n        meta: options?.meta ?? get().queries[hashedKey]?.meta,\n        keyString: get().queries[hashedKey]?.keyString ?? keyToString(key),\n      });\n      syncTagsIndex(hashedKey, options?.tags);\n      evictLRUIfNeeded();\n      scheduleFlush();\n      devtoolsEmit(\"setQueryData\", { key: hashedKey });\n    },\n\n    addObserver(key) {\n      const hashedKey = hashKey(key);\n      const next = (observers.get(hashedKey) ?? 0) + 1;\n      observers.set(hashedKey, next);\n      devtoolsEmit(\"observer:add\", { key: hashedKey, count: next });\n    },\n\n    removeObserver(key) {\n      const hashedKey = hashKey(key);\n      const prev = observers.get(hashedKey) ?? 0;\n      const next = Math.max(0, prev - 1);\n      if (next === 0) observers.delete(hashedKey);\n      else observers.set(hashedKey, next);\n      devtoolsEmit(\"observer:remove\", { key: hashedKey, count: next });\n    },\n\n    getObserversCount(key) {\n      const hashedKey = hashKey(key);\n      return observers.get(hashedKey) ?? 0;\n    },\n\n    getInFlightDirection(key) {\n      const hashedKey = hashKey(key);\n      return inFlightMeta.get(hashedKey)?.direction;\n    },\n\n    clear() {\n      Object.keys(get().queries).forEach((k) => get().abort(k));\n\n      if (isBrowser) {\n        pollers.forEach((p) => window.clearInterval(p.timer));\n      }\n      pollers.clear();\n      fetchers.clear();\n      infiniteFetchers.clear();\n      selectMemo.clear();\n      tagIndex.clear();\n      aborters.clear();\n      mutationAborters.clear();\n      keyMap.clear();\n      observers.clear();\n      inFlightMeta.clear();\n\n      set({ queries: {}, inFlight: {}, mutations: {} });\n      scheduleFlush();\n      debugLog(\"clear\");\n      devtoolsEmit(\"clear\", {});\n      broadcast({ type: \"clear\", payload: {} });\n    },\n\n    getSnapshot() {\n      const s = get();\n      return {\n        config: s.config,\n        metrics: s.metrics,\n        queryKeys: Object.keys(s.queries),\n        inFlightKeys: Object.keys(s.inFlight).filter((k) => !!s.inFlight[k]),\n        mutationKeys: Object.keys(s.mutations),\n      };\n    },\n  }));\n\n  const debugLog = (...args: unknown[]) => {\n    const { config } = store.getState();\n    if (!config.debug) return;\n    console.debug(\"[QueryStore]\", ...args);\n  };\n\n  const bump = (partial: Partial<Metrics>) => {\n    store.setState((s) => ({\n      metrics: {\n        ...s.metrics,\n        ...Object.fromEntries(\n          Object.entries(partial).map(([k, v]) => [\n            k,\n            (s.metrics as any)[k] + (v as number),\n          ])\n        ),\n      },\n    }));\n  };\n\n  const serializeQueries = (queries: Record<QueryKeyHash, QueryEntry>) => {\n    const out: Record<QueryKeyHash, Omit<QueryEntry, \"fetcher\">> = {};\n    Object.entries(queries).forEach(([k, q]) => {\n      const { fetcher: _f, error: _e, meta: _m, ...rest } = q;\n      out[k] = rest;\n    });\n    return out;\n  };\n\n  const devtoolsEmit = (type: string, payload: unknown) => {\n    const { devtools } = store.getState().config;\n    if (!isBrowser) return;\n    if (!devtools.enabled) return;\n\n    if (devtools.emitEvents) {\n      try {\n        window.dispatchEvent(\n          new CustomEvent(devtools.eventName, {\n            detail: { type, payload, ts: Date.now() },\n          })\n        );\n      } catch {}\n    }\n\n    if (store.getState().config.debug) {\n      debugLog(\"event\", type, payload);\n    }\n  };\n\n  const scheduleFlush = () => {\n    if (!isBrowser) return;\n    const { persistence } = store.getState().config;\n    if (persistence.mode === \"none\") return;\n\n    if (flushTimer) window.clearTimeout(flushTimer);\n    flushTimer = window.setTimeout(async () => {\n      flushTimer = null;\n      const { config, queries } = store.getState();\n      const payload = serializeQueries(queries);\n\n      try {\n        if (config.persistence.mode === \"session\") {\n          sessionStorage.setItem(\n            config.persistence.storageKey,\n            JSON.stringify(payload)\n          );\n          debugLog(\"persist(session) ok\");\n        } else if (config.persistence.mode === \"indexeddb\") {\n          await idbSet(\n            config.persistence.dbName,\n            config.persistence.storeName,\n            config.persistence.storageKey,\n            payload\n          );\n          debugLog(\"persist(indexeddb) ok\");\n        }\n      } catch (e) {\n        debugLog(\"persist failed\", e);\n      }\n    }, store.getState().config.persistence.flushDebounceMs);\n  };\n\n  const restorePersisted = async () => {\n    if (!isBrowser) return;\n    const { persistence } = store.getState().config;\n    if (persistence.mode === \"none\") return;\n\n    try {\n      if (persistence.mode === \"session\") {\n        const raw = sessionStorage.getItem(persistence.storageKey);\n        if (!raw) return;\n        const parsed = JSON.parse(raw) as Record<\n          QueryKeyHash,\n          Omit<QueryEntry, \"fetcher\">\n        >;\n        store.getState().hydrate(parsed);\n        debugLog(\"restore(session) ok\");\n      } else if (persistence.mode === \"indexeddb\") {\n        const parsed = await idbGet<\n          Record<QueryKeyHash, Omit<QueryEntry, \"fetcher\">>\n        >(persistence.dbName, persistence.storeName, persistence.storageKey);\n        if (!parsed) return;\n        store.getState().hydrate(parsed);\n        debugLog(\"restore(indexeddb) ok\");\n      }\n    } catch (e) {\n      debugLog(\"restore failed\", e);\n    }\n  };\n\n  const withDraft = (\n    fn: (draft: Record<QueryKeyHash, QueryEntry>) => void,\n    flush = true\n  ) => {\n    if (batchDepth > 0) {\n      if (!pendingQueries) pendingQueries = { ...store.getState().queries };\n      fn(pendingQueries);\n      if (flush) flushRequested = true;\n      return;\n    }\n    store.setState((s) => {\n      const next = { ...s.queries };\n      fn(next);\n      return { queries: next };\n    });\n    if (flush) scheduleFlush();\n  };\n\n  const setEntry = (key: QueryKeyHash, patch: Partial<QueryEntry>) => {\n    withDraft((draft) => {\n      const prev = draft[key];\n      const hasData = Object.prototype.hasOwnProperty.call(patch, \"data\");\n      const nextData = hasData\n        ? applyStructuralSharing(prev?.data, patch.data as any)\n        : prev?.data;\n      draft[key] = {\n        data: nextData,\n        error: prev?.error,\n        meta: prev?.meta,\n        keyString: prev?.keyString,\n        fetchedAt: prev?.fetchedAt,\n        accessedAt: prev?.accessedAt,\n        staleTime: prev?.staleTime ?? DEFAULT_STALE_TIME,\n        cacheTime: prev?.cacheTime ?? DEFAULT_CACHE_TIME,\n        refetchInterval: prev?.refetchInterval,\n        fetcher: prev?.fetcher,\n        tags: prev?.tags ?? [],\n        retry: prev?.retry,\n        lastAbortAt: prev?.lastAbortAt,\n        ...patch,\n      };\n    });\n  };\n\n  const touch = (key: QueryKeyHash) => {\n    setEntry(key, { accessedAt: Date.now() });\n  };\n\n  const evictLRUIfNeeded = () => {\n    const { maxEntries } = store.getState().config;\n    const queries = store.getState().queries;\n    const keys = Object.keys(queries);\n    if (keys.length <= maxEntries) return;\n\n    const sorted = keys\n      .map((k) => {\n        const q = queries[k];\n        const t = q.accessedAt ?? q.fetchedAt ?? 0;\n        return { k, t };\n      })\n      .sort((a, b) => a.t - b.t);\n\n    const toRemove = sorted.slice(0, Math.max(0, keys.length - maxEntries));\n    if (toRemove.length === 0) return;\n\n    store.getState().batch(() => {\n      toRemove.forEach(({ k }) => {\n        store.getState().invalidate(k);\n      });\n    });\n\n    bump({ lruEvictions: toRemove.length });\n    debugLog(\n      \"LRU evicted\",\n      toRemove.map((x) => x.k)\n    );\n    devtoolsEmit(\"lru\", { keys: toRemove.map((x) => x.k) });\n  };\n\n  const ensurePoller = (key: QueryKeyHash, interval?: number) => {\n    if (!isBrowser) return;\n\n    if (!interval || interval <= 0) {\n      const existing = pollers.get(key);\n      if (existing) window.clearInterval(existing.timer);\n      pollers.delete(key);\n      return;\n    }\n\n    const existing = pollers.get(key);\n    if (existing && existing.interval === interval) return;\n    if (existing) window.clearInterval(existing.timer);\n\n    const timer = window.setInterval(() => {\n      const fetcher = fetchers.get(key);\n      const entry = store.getState().queries[key];\n      if (!fetcher || !entry) return;\n      const originalKey = resolveKey(key);\n\n      if (infiniteFetchers.has(key)) {\n        store\n          .getState()\n          .refetchInfiniteQuery(originalKey)\n          .catch(() => {});\n        return;\n      }\n\n      store\n        .getState()\n        .fetchQuery(originalKey, {\n          fetcher: fetcher as any,\n          staleTime: entry.staleTime,\n          cacheTime: entry.cacheTime,\n          background: true,\n          skipStaleWhileRevalidate: true,\n          refetchInterval: interval,\n          tags: entry.tags,\n          retry: entry.retry,\n        })\n        .catch(() => {});\n    }, interval);\n\n    pollers.set(key, { timer, interval });\n  };\n\n  const syncTagsIndex = (key: QueryKeyHash, nextTags?: string[]) => {\n    if (!nextTags) return;\n\n    removeKeyFromAllTags(key);\n\n    nextTags.forEach((t) => {\n      if (!tagIndex.has(t)) tagIndex.set(t, new Set());\n      tagIndex.get(t)!.add(key);\n    });\n  };\n\n  const removeKeyFromAllTags = (key: QueryKeyHash) => {\n    tagIndex.forEach((setKeys) => {\n      setKeys.delete(key);\n    });\n\n    Array.from(tagIndex.entries()).forEach(([t, setKeys]) => {\n      if (setKeys.size === 0) tagIndex.delete(t);\n    });\n  };\n\n  const refetchStaleQueries = () => {\n    if (typeof navigator !== \"undefined\" && navigator.onLine === false) return;\n    const { queries, fetchQuery } = store.getState();\n    Object.entries(queries).forEach(([key, q]) => {\n      const observersCount = observers.get(key) ?? 0;\n      if (observersCount === 0) return;\n      if (!q.data) return;\n      const isStale = !q.fetchedAt || Date.now() - q.fetchedAt > q.staleTime;\n      if (!isStale) return;\n\n      bump({ backgroundFetches: 1 });\n      const originalKey = resolveKey(key);\n      if (infiniteFetchers.has(key)) {\n        store.getState().refetchInfiniteQuery(originalKey).catch(() => {});\n        return;\n      }\n\n      const f = fetchers.get(key);\n      if (!f) return;\n      fetchQuery(originalKey, {\n        fetcher: f as any,\n        staleTime: q.staleTime,\n        cacheTime: q.cacheTime,\n        background: true,\n        skipStaleWhileRevalidate: true,\n        refetchInterval: q.refetchInterval,\n        tags: q.tags,\n        retry: q.retry,\n      }).catch(() => {});\n    });\n  };\n\n  if (isBrowser) {\n    restorePersisted().catch(() => {});\n\n    if (cfg.refetchOnFocus) {\n      window.addEventListener(\"focus\", () => {\n        refetchStaleQueries();\n      });\n    }\n\n    if (cfg.refetchOnOnline) {\n      window.addEventListener(\"online\", () => {\n        refetchStaleQueries();\n      });\n    }\n\n    if (cfg.refetchOnReconnect) {\n      window.addEventListener(\"focus\", () => {\n        refetchStaleQueries();\n      });\n    }\n\n    if (cfg.devtools.enabled && cfg.devtools.exposeToWindow) {\n      (window as any).__QUERY_STORE__ = store;\n      (window as any).__QUERY_STORE_GET_SNAPSHOT__ = () =>\n        store.getState().getSnapshot();\n      devtoolsEmit(\"devtools:exposed\", {});\n    }\n\n    if (cfg.devtools.overlay?.enabled) {\n      const position = cfg.devtools.overlay.position ?? \"bottom-right\";\n      const styleBase =\n        \"position:fixed;z-index:2147483647;padding:8px 10px;background:#0f1115;color:#f8f8f2;border-radius:8px;font:12px/1.4 monospace;opacity:0.9;\";\n      const positionStyle =\n        position === \"bottom-left\"\n          ? \"bottom:12px;left:12px;\"\n          : position === \"top-right\"\n            ? \"top:12px;right:12px;\"\n            : position === \"top-left\"\n              ? \"top:12px;left:12px;\"\n              : \"bottom:12px;right:12px;\";\n      const root = document.createElement(\"div\");\n      root.setAttribute(\"style\", `${styleBase}${positionStyle}`);\n      const render = () => {\n        const { metrics, queries, inFlight, mutations } = store.getState();\n        root.textContent =\n          `queries:${Object.keys(queries).length} ` +\n          `inFlight:${Object.keys(inFlight).filter((k) => !!inFlight[k]).length} ` +\n          `mutations:${Object.keys(mutations).length} ` +\n          `hits:${metrics.hits} ` +\n          `misses:${metrics.misses} ` +\n          `errors:${metrics.errors}`;\n      };\n      render();\n      document.body.appendChild(root);\n      store.subscribe(render);\n    }\n\n    if (cfg.multiTabSync.enabled && channel) {\n      channel.onmessage = (event) => {\n        const message = event.data as {\n          type: string;\n          payload?: any;\n          sourceId?: string;\n        };\n        if (message.sourceId === instanceId) return;\n        suppressBroadcast = true;\n        try {\n          if (message.type === \"invalidate\") {\n            store.getState().invalidate(message.payload.key);\n          }\n          if (message.type === \"invalidateByPrefix\") {\n            store.getState().invalidateByPrefix(message.payload.prefix);\n          }\n          if (message.type === \"invalidateTags\") {\n            store.getState().invalidateTags(message.payload.tags);\n          }\n          if (message.type === \"clear\") {\n            store.getState().clear();\n          }\n        } finally {\n          suppressBroadcast = false;\n        }\n      };\n    }\n  }\n\n  if (cfg.gcIntervalMs && isBrowser) {\n    window.setInterval(() => {\n      store.getState().gc();\n    }, cfg.gcIntervalMs);\n  }\n\n  return store;\n}\n\nexport const useQueryStore = createQueryClient();\r\n","import { Metrics, QueryClientConfig } from \"../types\";\n\nexport const DEFAULT_STALE_TIME = 30_000;\nexport const DEFAULT_CACHE_TIME = 5 * 60_000;\n\nexport const createMetrics = (): Metrics => ({\n  hits: 0,\n  misses: 0,\n  fetches: 0,\n  backgroundFetches: 0,\n  dedupes: 0,\n  errors: 0,\n  invalidations: 0,\n  gcEvictions: 0,\n  lruEvictions: 0,\n  prefetched: 0,\n  mutations: 0,\n  optimisticApplied: 0,\n  optimisticRolledBack: 0,\n  aborts: 0,\n  retries: 0,\n});\n\nexport const defaultConfig: QueryClientConfig = {\n  maxEntries: 200,\n  persistence: {\n    mode: \"indexeddb\",\n    storageKey: \"__query_cache__\",\n    dbName: \"__query_cache_db__\",\n    storeName: \"cache\",\n    flushDebounceMs: 250,\n  },\n  debug: false,\n  refetchOnFocus: true,\n  refetchOnReconnect: false,\n  refetchOnOnline: false,\n  retry: {\n    attempts: 1,\n    delay: 300,\n    retryOn: () => true,\n  },\n  staleWhileRevalidate: false,\n  selectMemoMaxEntries: 500,\n  structuralSharing: true,\n  gcIntervalMs: 60_000,\n  suspense: false,\n  throwOnError: false,\n  queryDefaults: [],\n  mutationDefaults: [],\n  multiTabSync: {\n    enabled: false,\n    channelName: \"__query_store_sync__\",\n  },\n  devtools: {\n    enabled: true,\n    exposeToWindow: true,\n    emitEvents: false,\n    eventName: \"__query_store__\",\n    overlay: {\n      enabled: false,\n      position: \"bottom-right\",\n    },\n  },\n};\n","import { QueryKey, QueryKeyHash } from \"../types\";\n\nexport const stableStringify = (value: unknown): string => {\n  const stack = new Set<unknown>();\n  const walk = (val: unknown): string => {\n    if (val === null) return \"null\";\n    const type = typeof val;\n    if (type === \"string\") return JSON.stringify(val);\n    if (type === \"number\") return Number.isFinite(val) ? String(val) : \"null\";\n    if (type === \"boolean\") return val ? \"true\" : \"false\";\n    if (type === \"undefined\") return \"\\\"__undefined__\\\"\";\n    if (type === \"bigint\") return JSON.stringify(`__bigint__:${val}`);\n    if (type === \"function\") return \"\\\"__function__\\\"\";\n    if (val instanceof Date) return JSON.stringify(`__date__:${val.toISOString()}`);\n    if (Array.isArray(val)) {\n      return `[${val.map((item) => walk(item)).join(\",\")}]`;\n    }\n    if (type === \"object\") {\n      if (stack.has(val)) throw new Error(\"Circular value in query key\");\n      stack.add(val);\n      const obj = val as Record<string, unknown>;\n      const keys = Object.keys(obj).sort();\n      const result = `{${keys\n        .map((k) => `${JSON.stringify(k)}:${walk(obj[k])}`)\n        .join(\",\")}}`;\n      stack.delete(val);\n      return result;\n    }\n    return \"\\\"__unknown__\\\"\";\n  };\n  return walk(value);\n};\n\nexport const hashKey = (key: QueryKey): QueryKeyHash => {\n  if (typeof key === \"string\") return key;\n  return `k:${stableStringify(key)}`;\n};\n\nexport const keyToString = (key: QueryKey): string => {\n  if (typeof key === \"string\") return key;\n  const first = key[0];\n  if (typeof first === \"string\") return first;\n  return hashKey(key);\n};\n","export const isPlainObject = (value: unknown): value is Record<string, unknown> => {\n  if (!value || typeof value !== \"object\") return false;\n  const proto = Object.getPrototypeOf(value);\n  return proto === Object.prototype || proto === null;\n};\n\nexport const replaceEqualDeep = <T>(a: T, b: T): T => {\n  if (a === b) return a;\n  if (Array.isArray(a) && Array.isArray(b)) {\n    const length = b.length;\n    const result = new Array(length);\n    let equal = a.length === length;\n    for (let i = 0; i < length; i += 1) {\n      result[i] = replaceEqualDeep(a[i], b[i]);\n      if (result[i] !== a[i]) equal = false;\n    }\n    return (equal ? a : (result as unknown as T));\n  }\n  if (isPlainObject(a) && isPlainObject(b)) {\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    if (aKeys.length !== bKeys.length) {\n      const out: Record<string, unknown> = {};\n      bKeys.forEach((k) => {\n        out[k] = replaceEqualDeep((a as any)[k], (b as any)[k]);\n      });\n      return out as T;\n    }\n    let equal = true;\n    const out: Record<string, unknown> = {};\n    bKeys.forEach((k) => {\n      const value = replaceEqualDeep((a as any)[k], (b as any)[k]);\n      out[k] = value;\n      if (value !== (a as any)[k]) equal = false;\n    });\n    return (equal ? a : (out as T));\n  }\n  return b;\n};\n","import { RetryOptions } from \"../types\";\n\nexport const isAbortError = (e: unknown) => {\n  if (!e) return false;\n  const anyE = e as any;\n  return anyE?.name === \"AbortError\" || anyE?.code === 20;\n};\n\nexport const sleep = (ms: number) =>\n  new Promise<void>((resolve) => setTimeout(resolve, ms));\n\nexport const runWithRetry = async <T>(\n  fn: (attemptIndex: number) => Promise<T>,\n  retryCfg: RetryOptions,\n  onRetryBump: (n: number) => void,\n  onRetryEmit?: (attempt: number, attempts: number) => void\n): Promise<T> => {\n  const attempts = Math.max(1, retryCfg.attempts ?? 1);\n  const retryOn = retryCfg.retryOn ?? (() => true);\n  const delayCfg = retryCfg.delay ?? 0;\n\n  let lastErr: unknown;\n\n  for (let i = 0; i < attempts; i++) {\n    try {\n      if (i > 0) {\n        onRetryBump(1);\n        onRetryEmit?.(i + 1, attempts);\n      }\n      return await fn(i);\n    } catch (e) {\n      lastErr = e;\n      if (isAbortError(e)) throw e;\n      if (i === attempts - 1) break;\n      if (!retryOn(e, i + 1)) break;\n\n      const ms =\n        typeof delayCfg === \"function\"\n          ? delayCfg(i + 1)\n          : (delayCfg as number);\n      if (ms > 0) await sleep(ms);\n    }\n  }\n\n  throw lastErr;\n};\n","type IDBPayload = {\n  key: string;\n  value: unknown;\n};\n\nexport function idbOpen(dbName: string, storeName: string): Promise<IDBDatabase> {\n  return new Promise((resolve, reject) => {\n    const req = indexedDB.open(dbName, 1);\n    req.onupgradeneeded = () => {\n      const db = req.result;\n      if (!db.objectStoreNames.contains(storeName)) {\n        db.createObjectStore(storeName, { keyPath: \"key\" });\n      }\n    };\n    req.onsuccess = () => resolve(req.result);\n    req.onerror = () => reject(req.error);\n  });\n}\n\nexport async function idbSet(\n  dbName: string,\n  storeName: string,\n  key: string,\n  value: unknown\n) {\n  const db = await idbOpen(dbName, storeName);\n  await new Promise<void>((resolve, reject) => {\n    const tx = db.transaction(storeName, \"readwrite\");\n    tx.oncomplete = () => resolve();\n    tx.onerror = () => reject(tx.error);\n    tx.objectStore(storeName).put({ key, value } satisfies IDBPayload);\n  });\n  db.close();\n}\n\nexport async function idbGet<T>(\n  dbName: string,\n  storeName: string,\n  key: string\n): Promise<T | undefined> {\n  const db = await idbOpen(dbName, storeName);\n  const result = await new Promise<T | undefined>((resolve, reject) => {\n    const tx = db.transaction(storeName, \"readonly\");\n    tx.onerror = () => reject(tx.error);\n    const req = tx.objectStore(storeName).get(key);\n    req.onsuccess = () =>\n      resolve((req.result?.value ?? undefined) as T | undefined);\n    req.onerror = () => reject(req.error);\n  });\n  db.close();\n  return result;\n}\n","import { clearAuthToken, setAuthToken } from \"./token\";\nimport { useQueryStore } from \"../store/client\";\n\ntype BetterAuthSignIn<TEmail = unknown, TSocial = unknown, TOAuth2 = unknown> =\n  | ((payload: TEmail) => Promise<unknown>)\n  | {\n      email?: (payload: TEmail) => Promise<unknown>;\n      social?: (payload: TSocial) => Promise<unknown>;\n      oauth2?: (payload: TOAuth2) => Promise<unknown>;\n    };\n\ntype BetterAuthSignUp<TEmail = unknown> =\n  | ((payload: TEmail) => Promise<unknown>)\n  | {\n      email?: (payload: TEmail) => Promise<unknown>;\n    };\n\nexport type BetterAuthClient<\n  TSignIn = unknown,\n  TSignUp = unknown,\n  TSession = unknown,\n  TSocialSignIn = unknown,\n  TOAuth2SignIn = unknown,\n  TRequestPasswordReset = unknown,\n  TResetPassword = unknown,\n  TChangePassword = unknown,\n> = {\n  signIn?: BetterAuthSignIn<TSignIn, TSocialSignIn, TOAuth2SignIn>;\n  signUp?: BetterAuthSignUp<TSignUp>;\n  signOut?: () => Promise<unknown>;\n  getSession?: () => Promise<TSession | null | undefined>;\n  requestPasswordReset?: (payload: TRequestPasswordReset) => Promise<unknown>;\n  resetPassword?: (payload: TResetPassword) => Promise<unknown>;\n  changePassword?: (payload: TChangePassword) => Promise<unknown>;\n};\n\nexport type BetterAuthBridgeOptions = {\n  getTokenFromResult?: (result: unknown) => string | undefined;\n  getTokenFromSession?: (session: unknown) => string | undefined;\n  setToken?: (token?: string) => void;\n  clearCacheOnSignOut?: boolean;\n};\n\nconst resolveToken = (value: unknown) => {\n  if (!value || typeof value !== \"object\") return undefined;\n  const anyValue = value as any;\n  return (\n    anyValue.token ??\n    anyValue.accessToken ??\n    anyValue.session?.token ??\n    anyValue.session?.accessToken ??\n    anyValue.data?.token ??\n    anyValue.data?.session?.token\n  );\n};\n\nexport const createBetterAuthBridge = <\n  TSignIn = unknown,\n  TSignUp = unknown,\n  TSession = unknown,\n  TSocialSignIn = unknown,\n  TOAuth2SignIn = unknown,\n  TRequestPasswordReset = unknown,\n  TResetPassword = unknown,\n  TChangePassword = unknown,\n>(\n  client: BetterAuthClient<\n    TSignIn,\n    TSignUp,\n    TSession,\n    TSocialSignIn,\n    TOAuth2SignIn,\n    TRequestPasswordReset,\n    TResetPassword,\n    TChangePassword\n  >,\n  options?: BetterAuthBridgeOptions\n) => {\n  const setToken = options?.setToken ?? setAuthToken;\n  const getTokenFromResult = options?.getTokenFromResult ?? resolveToken;\n  const getTokenFromSession = options?.getTokenFromSession ?? resolveToken;\n  const clearCacheOnSignOut = options?.clearCacheOnSignOut ?? true;\n  const resolveSignInEmail = () => {\n    if (typeof client.signIn === \"function\") return client.signIn;\n    return client.signIn?.email;\n  };\n  const resolveSignInSocial = () => {\n    if (!client.signIn || typeof client.signIn === \"function\") return undefined;\n    return client.signIn.social;\n  };\n  const resolveSignInOAuth2 = () => {\n    if (!client.signIn || typeof client.signIn === \"function\") return undefined;\n    return client.signIn.oauth2;\n  };\n  const signUpEmail = () => {\n    if (typeof client.signUp === \"function\") return client.signUp;\n    return client.signUp?.email;\n  };\n\n  const syncFromResult = (result: unknown) => {\n    const token = getTokenFromResult(result);\n    if (token) setToken(token);\n    return result;\n  };\n\n  const refreshSession = async () => {\n    if (!client.getSession) return undefined;\n    const session = await client.getSession();\n    const token = getTokenFromSession(session);\n    setToken(token);\n    return session;\n  };\n\n  const register = async (payload: TSignUp) => {\n    const handler = signUpEmail();\n    if (!handler) {\n      throw new Error(\"better-auth client missing signUp.email\");\n    }\n    const result = await handler(payload);\n    return syncFromResult(result);\n  };\n\n  const signIn = async (payload: TSignIn) => {\n    const handler = resolveSignInEmail();\n    if (!handler) {\n      throw new Error(\"better-auth client missing signIn.email\");\n    }\n    const result = await handler(payload);\n    return syncFromResult(result);\n  };\n\n  const signInSocial = async (payload: TSocialSignIn) => {\n    const handler = resolveSignInSocial();\n    if (!handler) {\n      throw new Error(\"better-auth client missing signIn.social\");\n    }\n    const result = await handler(payload);\n    return syncFromResult(result);\n  };\n  const signInOAuth2 = async (payload: TOAuth2SignIn) => {\n    const handler = resolveSignInOAuth2();\n    if (!handler) {\n      throw new Error(\"better-auth client missing signIn.oauth2\");\n    }\n    const result = await handler(payload);\n    return syncFromResult(result);\n  };\n\n  const signOut = async () => {\n    const result = await client.signOut?.();\n    clearAuthToken();\n    if (clearCacheOnSignOut) {\n      useQueryStore.getState().clear();\n    }\n    return result;\n  };\n  const requestPasswordReset = async (payload: TRequestPasswordReset) => {\n    if (!client.requestPasswordReset) {\n      throw new Error(\"better-auth client missing requestPasswordReset\");\n    }\n    return client.requestPasswordReset(payload);\n  };\n  const resetPassword = async (payload: TResetPassword) => {\n    if (!client.resetPassword) {\n      throw new Error(\"better-auth client missing resetPassword\");\n    }\n    return client.resetPassword(payload);\n  };\n  const changePassword = async (payload: TChangePassword) => {\n    if (!client.changePassword) {\n      throw new Error(\"better-auth client missing changePassword\");\n    }\n    return client.changePassword(payload);\n  };\n\n  return {\n    client,\n    register,\n    signIn,\n    signInSocial,\n    signInOAuth2,\n    signOut,\n    refreshSession,\n    requestPasswordReset,\n    resetPassword,\n    changePassword,\n  };\n};\n","import { createBetterAuthBridge } from \"./betterAuth\";\n\nexport type AuthBridgeFromEnvOptions = {\n  baseURL?: string;\n  plugins?: unknown[];\n  clearCacheOnSignOut?: boolean;\n};\n\nconst resolveDefaultBaseURL = () => {\n  if (typeof window !== \"undefined\") {\n    return `${window.location.origin}/api/auth`;\n  }\n  return \"/api/auth\";\n};\n\nexport const createAuthBridgeFromEnv = async (\n  options: AuthBridgeFromEnvOptions = {}\n) => {\n  let createAuthClient: (opts: {\n    baseURL: string;\n    plugins?: unknown[];\n  }) => unknown;\n\n  try {\n    const mod = await import(\"better-auth/client\");\n    createAuthClient = (mod as any).createAuthClient;\n    if (!createAuthClient) {\n      throw new Error(\"better-auth/client did not export createAuthClient\");\n    }\n  } catch (error) {\n    throw new Error(\n      \"better-auth is required for createAuthBridgeFromEnv. Install it with `npm i better-auth`.\"\n    );\n  }\n\n  const client = createAuthClient({\n    baseURL: options.baseURL ?? resolveDefaultBaseURL(),\n    plugins: options.plugins,\n  });\n\n  return createBetterAuthBridge(client as any, {\n    clearCacheOnSignOut: options.clearCacheOnSignOut,\n  });\n};\n","import type { QueryKey, QueryStore } from \"../types\";\nimport { hashKey } from \"../utils/keys\";\nimport { useQueryStore } from \"../store\";\n\nexport type SocketLike = {\n  on: (event: string, handler: (payload: any) => void) => void;\n  off: (event: string, handler: (payload: any) => void) => void;\n};\n\nexport type SocketCacheEvent<TPayload = unknown> = {\n  event: string;\n  key: (payload: TPayload) => QueryKey;\n  update?: (prev: unknown | undefined, payload: TPayload) => unknown;\n  invalidate?: boolean;\n  setOptions?: {\n    staleTime?: number;\n    cacheTime?: number;\n    refetchInterval?: number;\n    tags?: string[];\n    meta?: unknown;\n    fetchedAt?: number;\n  };\n};\n\nexport type SocketCacheBridgeOptions = {\n  socket: SocketLike;\n  store?: { getState: () => QueryStore };\n  events: SocketCacheEvent[];\n  onError?: (error: unknown, payload: unknown, event: string) => void;\n};\n\nexport type SocketCacheConnection = {\n  socket: SocketLike & { disconnect?: () => void; close?: () => void };\n  start: () => void;\n  stop: () => void;\n  dispose: () => void;\n};\n\nexport type ConnectSocketCacheOptions = Omit<SocketCacheBridgeOptions, \"socket\"> & {\n  url: string;\n  socketOptions?: Record<string, unknown>;\n  autoStart?: boolean;\n};\n\nexport const createSocketCacheBridge = (options: SocketCacheBridgeOptions) => {\n  const store = options.store ?? useQueryStore;\n  const handlers = new Map<string, Array<(payload: any) => void>>();\n\n  const start = () => {\n    options.events.forEach((evt) => {\n      const handler = (payload: unknown) => {\n        try {\n          const key = evt.key(payload);\n          if (evt.invalidate) {\n            store.getState().invalidate(key);\n            return;\n          }\n          if (!evt.update) return;\n          const hashedKey = hashKey(key);\n          const prev = store.getState().queries[hashedKey]?.data;\n          const next = evt.update(prev, payload);\n          store.getState().setQueryData(key, next, evt.setOptions);\n        } catch (error) {\n          options.onError?.(error, payload, evt.event);\n        }\n      };\n      const list = handlers.get(evt.event) ?? [];\n      list.push(handler);\n      handlers.set(evt.event, list);\n      options.socket.on(evt.event, handler);\n    });\n  };\n\n  const stop = () => {\n    handlers.forEach((list, event) => {\n      list.forEach((handler) => {\n        options.socket.off(event, handler);\n      });\n    });\n    handlers.clear();\n  };\n\n  return { start, stop };\n};\n\nexport const connectSocketCache = async (\n  options: ConnectSocketCacheOptions\n): Promise<SocketCacheConnection> => {\n  const { url, socketOptions, autoStart = true, ...bridgeOptions } = options;\n\n  let ioFactory: (\n    url: string,\n    opts?: Record<string, unknown>\n  ) => SocketLike & { disconnect?: () => void; close?: () => void };\n\n  try {\n    const mod = await import(\"socket.io-client\");\n    ioFactory = (mod as any).io;\n    if (!ioFactory) {\n      throw new Error(\"socket.io-client did not export io()\");\n    }\n  } catch {\n    throw new Error(\n      \"socket.io-client is required for connectSocketCache. Install it with `npm i socket.io-client`.\"\n    );\n  }\n\n  const socket = ioFactory(url, socketOptions);\n  const bridge = createSocketCacheBridge({\n    ...bridgeOptions,\n    socket,\n  });\n\n  if (autoStart) bridge.start();\n\n  const dispose = () => {\n    bridge.stop();\n    if (typeof (socket as any).disconnect === \"function\") {\n      (socket as any).disconnect();\n      return;\n    }\n    if (typeof (socket as any).close === \"function\") {\n      (socket as any).close();\n    }\n  };\n\n  return {\n    socket,\n    start: bridge.start,\n    stop: bridge.stop,\n    dispose,\n  };\n};\r\n","import type { QueryKey, QueryStore } from \"../types\";\nimport { hashKey } from \"../utils/keys\";\nimport { useQueryStore } from \"../store\";\n\nexport type EventSourceLike = {\n  addEventListener: (event: string, handler: (event: MessageEvent) => void) => void;\n  removeEventListener: (\n    event: string,\n    handler: (event: MessageEvent) => void\n  ) => void;\n  close?: () => void;\n};\n\nexport type SseCacheEvent<TPayload = unknown> = {\n  event: string;\n  key: (payload: TPayload) => QueryKey;\n  update?: (prev: unknown | undefined, payload: TPayload) => unknown;\n  invalidate?: boolean;\n  parse?: (event: MessageEvent) => TPayload;\n  setOptions?: {\n    staleTime?: number;\n    cacheTime?: number;\n    refetchInterval?: number;\n    tags?: string[];\n    meta?: unknown;\n    fetchedAt?: number;\n  };\n};\n\nexport type SseCacheBridgeOptions = {\n  source: EventSourceLike;\n  store?: { getState: () => QueryStore };\n  events: SseCacheEvent[];\n  parse?: (event: MessageEvent) => unknown;\n  onError?: (error: unknown, event: MessageEvent, name: string) => void;\n};\n\nexport type SseCacheConnection = {\n  source: EventSourceLike;\n  start: () => void;\n  stop: () => void;\n  dispose: () => void;\n};\n\nexport type ConnectSseCacheOptions = Omit<SseCacheBridgeOptions, \"source\"> & {\n  url: string;\n  eventSourceInit?: EventSourceInit;\n  autoStart?: boolean;\n};\n\nconst defaultParse = (event: MessageEvent) => {\n  if (typeof event.data !== \"string\") return event.data;\n  try {\n    return JSON.parse(event.data);\n  } catch {\n    return event.data;\n  }\n};\n\nexport const createSseCacheBridge = (options: SseCacheBridgeOptions) => {\n  const store = options.store ?? useQueryStore;\n  const handlers = new Map<string, Array<(event: MessageEvent) => void>>();\n\n  const start = () => {\n    options.events.forEach((evt) => {\n      const handler = (event: MessageEvent) => {\n        try {\n          const parser = evt.parse ?? options.parse ?? defaultParse;\n          const payload = parser(event) as unknown;\n          const key = evt.key(payload as any);\n          if (evt.invalidate) {\n            store.getState().invalidate(key);\n            return;\n          }\n          if (!evt.update) return;\n          const hashedKey = hashKey(key);\n          const prev = store.getState().queries[hashedKey]?.data;\n          const next = evt.update(prev, payload as any);\n          store.getState().setQueryData(key, next, evt.setOptions);\n        } catch (error) {\n          options.onError?.(error, event, evt.event);\n        }\n      };\n      const list = handlers.get(evt.event) ?? [];\n      list.push(handler);\n      handlers.set(evt.event, list);\n      options.source.addEventListener(evt.event, handler);\n    });\n  };\n\n  const stop = () => {\n    handlers.forEach((list, event) => {\n      list.forEach((handler) => {\n        options.source.removeEventListener(event, handler);\n      });\n    });\n    handlers.clear();\n  };\n\n  return { start, stop };\n};\n\nexport const connectSseCache = (options: ConnectSseCacheOptions): SseCacheConnection => {\n  const { url, eventSourceInit, autoStart = true, ...bridgeOptions } = options;\n  if (typeof EventSource === \"undefined\") {\n    throw new Error(\"EventSource is not available in this environment.\");\n  }\n  const source = new EventSource(url, eventSourceInit);\n  const bridge = createSseCacheBridge({ ...bridgeOptions, source });\n  if (autoStart) bridge.start();\n\n  const dispose = () => {\n    bridge.stop();\n    source.close?.();\n  };\n\n  return {\n    source,\n    start: bridge.start,\n    stop: bridge.stop,\n    dispose,\n  };\n};\n","import type { QueryKey } from \"../types\";\nimport { createSocketCacheBridge, SocketLike } from \"./socket\";\n\nexport type ChatBridgeOptions<TMessage, TPresence, TTyping> = {\n  socket: SocketLike;\n  roomId: string;\n  messageKey?: QueryKey;\n  presenceKey?: QueryKey;\n  typingKey?: QueryKey;\n  getMessageId?: (message: TMessage) => unknown;\n  events?: {\n    message?: string;\n    presence?: string;\n    typing?: string;\n  };\n  onError?: (error: unknown, payload: unknown, event: string) => void;\n};\n\nconst dedupeById = <T>(list: T[], getId?: (item: T) => unknown) => {\n  if (!getId) return list;\n  const seen = new Set<unknown>();\n  return list.filter((item) => {\n    const id = getId(item);\n    if (id === undefined || id === null) return true;\n    if (seen.has(id)) return false;\n    seen.add(id);\n    return true;\n  });\n};\n\nexport const createChatRoomBridge = <\n  TMessage = unknown,\n  TPresence = unknown,\n  TTyping = unknown\n>(\n  options: ChatBridgeOptions<TMessage, TPresence, TTyping>\n) => {\n  const messageEvent = options.events?.message ?? \"message:new\";\n  const presenceEvent = options.events?.presence ?? \"presence:update\";\n  const typingEvent = options.events?.typing ?? \"typing:update\";\n  const messageKey = options.messageKey ?? [\"messages\", options.roomId];\n  const presenceKey = options.presenceKey ?? [\"presence\", options.roomId];\n  const typingKey = options.typingKey ?? [\"typing\", options.roomId];\n\n  return createSocketCacheBridge({\n    socket: options.socket,\n    events: [\n      {\n        event: messageEvent,\n        key: () => messageKey,\n        update: (prev, payload) => {\n          const list = Array.isArray(prev) ? (prev as TMessage[]) : [];\n          const next = [...list, payload as TMessage];\n          return dedupeById(next, options.getMessageId);\n        },\n      },\n      {\n        event: presenceEvent,\n        key: () => presenceKey,\n        update: (_prev, payload) => payload as TPresence,\n      },\n      {\n        event: typingEvent,\n        key: () => typingKey,\n        update: (_prev, payload) => payload as TTyping,\n      },\n    ],\n    onError: options.onError,\n  });\n};\n","export type SignalingTransport = {\n  on: (event: string, handler: (payload: any) => void) => void;\n  off: (event: string, handler: (payload: any) => void) => void;\n  emit: (event: string, payload: any) => void;\n};\n\nexport type WebRtcSignal = {\n  roomId: string;\n  from: string;\n  to?: string;\n  description?: RTCSessionDescriptionInit;\n  candidate?: RTCIceCandidateInit;\n};\n\nexport type WebRtcPeerOptions = {\n  id: string;\n  roomId: string;\n  onSignal: (payload: WebRtcSignal) => void;\n  onTrack?: (event: RTCTrackEvent) => void;\n  onData?: (data: string) => void;\n  onStateChange?: (state: RTCPeerConnectionState) => void;\n  iceServers?: RTCIceServer[];\n  stream?: MediaStream | null;\n};\n\nexport const createWebRtcPeer = (options: WebRtcPeerOptions) => {\n  const pc = new RTCPeerConnection({\n    iceServers: options.iceServers ?? [],\n  });\n\n  let dataChannel: RTCDataChannel | null = null;\n\n  if (options.stream) {\n    options.stream.getTracks().forEach((track) => {\n      pc.addTrack(track, options.stream as MediaStream);\n    });\n  }\n\n  pc.ontrack = (event) => options.onTrack?.(event);\n  pc.onconnectionstatechange = () =>\n    options.onStateChange?.(pc.connectionState);\n  pc.onicecandidate = (event) => {\n    if (!event.candidate) return;\n    options.onSignal({\n      roomId: options.roomId,\n      from: options.id,\n      candidate: event.candidate.toJSON(),\n    });\n  };\n\n  pc.ondatachannel = (event) => {\n    dataChannel = event.channel;\n    dataChannel.onmessage = (msg) => options.onData?.(String(msg.data));\n  };\n\n  const ensureDataChannel = () => {\n    if (dataChannel) return;\n    dataChannel = pc.createDataChannel(\"chat\");\n    dataChannel.onmessage = (msg) => options.onData?.(String(msg.data));\n  };\n\n  const start = async () => {\n    ensureDataChannel();\n    const offer = await pc.createOffer();\n    await pc.setLocalDescription(offer);\n    options.onSignal({\n      roomId: options.roomId,\n      from: options.id,\n      description: pc.localDescription ?? offer,\n    });\n  };\n\n  const handleSignal = async (payload: WebRtcSignal) => {\n    if (payload.from === options.id) return;\n    if (payload.roomId !== options.roomId) return;\n\n    if (payload.description) {\n      await pc.setRemoteDescription(payload.description);\n      if (payload.description.type === \"offer\") {\n        const answer = await pc.createAnswer();\n        await pc.setLocalDescription(answer);\n        options.onSignal({\n          roomId: options.roomId,\n          from: options.id,\n          description: pc.localDescription ?? answer,\n        });\n      }\n      return;\n    }\n\n    if (payload.candidate) {\n      try {\n        await pc.addIceCandidate(payload.candidate);\n      } catch {\n        // ignore\n      }\n    }\n  };\n\n  const sendData = (data: string) => {\n    dataChannel?.send(data);\n  };\n\n  const close = () => {\n    dataChannel?.close();\n    dataChannel = null;\n    pc.close();\n  };\n\n  return { pc, start, handleSignal, sendData, close };\n};\n\n","import { useQueryStore } from \"../store\";\n\nexport type StoreEventDetail = {\n  type: string;\n  payload: unknown;\n  ts: number;\n};\n\nexport type StoreEventReporterOptions = {\n  eventName?: string;\n  onEvent: (event: StoreEventDetail) => void;\n};\n\nexport const createStoreEventReporter = (\n  options: StoreEventReporterOptions\n) => {\n  if (typeof window === \"undefined\") {\n    return () => {};\n  }\n  const eventName =\n    options.eventName ?? useQueryStore.getState().config.devtools.eventName;\n\n  const handler = (event: Event) => {\n    const detail = (event as CustomEvent).detail as StoreEventDetail | undefined;\n    if (!detail) return;\n    options.onEvent(detail);\n  };\n\n  window.addEventListener(eventName, handler);\n  return () => {\n    window.removeEventListener(eventName, handler);\n  };\n};\n","import type { QueryFetcher, QueryKey } from \"../types\";\n\nexport type FetchTrace = {\n  key?: QueryKey;\n  label?: string;\n  start: number;\n  end: number;\n  duration: number;\n  success: boolean;\n  error?: unknown;\n};\n\nexport type FetchTraceHandlers = {\n  onStart?: (info: { key?: QueryKey; label?: string }) => void;\n  onSuccess?: (info: FetchTrace) => void;\n  onError?: (info: FetchTrace) => void;\n  onSettled?: (info: FetchTrace) => void;\n};\n\nexport const wrapFetcher = <T>(\n  fetcher: QueryFetcher<T>,\n  handlers: FetchTraceHandlers,\n  meta?: { key?: QueryKey; label?: string }\n): QueryFetcher<T> => {\n  return async (ctx?: { signal?: AbortSignal }) => {\n    const start = Date.now();\n    handlers.onStart?.({ key: meta?.key, label: meta?.label });\n    try {\n      const fn = fetcher as any;\n      const result =\n        typeof fn === \"function\" && fn.length >= 1 ? fn(ctx) : fn();\n      const data = await result;\n      const end = Date.now();\n      const trace: FetchTrace = {\n        key: meta?.key,\n        label: meta?.label,\n        start,\n        end,\n        duration: end - start,\n        success: true,\n      };\n      handlers.onSuccess?.(trace);\n      handlers.onSettled?.(trace);\n      return data;\n    } catch (error) {\n      const end = Date.now();\n      const trace: FetchTrace = {\n        key: meta?.key,\n        label: meta?.label,\n        start,\n        end,\n        duration: end - start,\n        success: false,\n        error,\n      };\n      handlers.onError?.(trace);\n      handlers.onSettled?.(trace);\n      throw error;\n    }\n  };\n};\n","import { FetchQueryOptions, QueryKey } from \"../types\";\nimport { hashKey } from \"../utils/keys\";\nimport { useQueryStore } from \"../store\";\n\nexport type PrefetchTask<T> = {\n  key: QueryKey;\n  options: FetchQueryOptions<T>;\n};\n\nexport type PrefetchSchedulerOptions = {\n  concurrency?: number;\n  delayMs?: number;\n  dedupe?: boolean;\n  maxPerSecond?: number;\n};\n\nexport const createPrefetchScheduler = (\n  options: PrefetchSchedulerOptions = {}\n) => {\n  const concurrency = Math.max(1, options.concurrency ?? 2);\n  const delayMs = Math.max(0, options.delayMs ?? 0);\n  const dedupe = options.dedupe ?? true;\n  const maxPerSecond = Math.max(0, options.maxPerSecond ?? 0);\n\n  const queue: Array<PrefetchTask<any>> = [];\n  const pending = new Set<string>();\n  let active = 0;\n  let draining = false;\n  let tokens = maxPerSecond > 0 ? maxPerSecond : Infinity;\n\n  const drain = () => {\n    if (draining) return;\n    draining = true;\n    if (maxPerSecond > 0 && typeof window !== \"undefined\") {\n      window.setInterval(() => {\n        tokens = maxPerSecond;\n      }, 1000);\n    }\n    const step = () => {\n      while (active < concurrency && queue.length > 0 && tokens > 0) {\n        const task = queue.shift()!;\n        const hashedKey = hashKey(task.key);\n        if (dedupe) pending.delete(hashedKey);\n        active += 1;\n        if (maxPerSecond > 0) tokens -= 1;\n        useQueryStore\n          .getState()\n          .prefetchQuery(task.key, task.options)\n          .catch(() => {})\n          .finally(() => {\n            active -= 1;\n            if (queue.length > 0) {\n              if (delayMs > 0) {\n                setTimeout(step, delayMs);\n              } else {\n                step();\n              }\n            } else {\n              draining = false;\n            }\n          });\n      }\n      if (queue.length === 0) {\n        draining = false;\n      }\n    };\n    step();\n  };\n\n  const schedule = <T>(key: QueryKey, options: FetchQueryOptions<T>) => {\n    const hashedKey = hashKey(key);\n    if (dedupe && pending.has(hashedKey)) {\n      return () => {};\n    }\n    if (dedupe) pending.add(hashedKey);\n    queue.push({ key, options });\n    drain();\n    return () => {\n      const idx = queue.findIndex(\n        (item) => hashKey(item.key) === hashedKey\n      );\n      if (idx >= 0) queue.splice(idx, 1);\n      if (dedupe) pending.delete(hashedKey);\n    };\n  };\n\n  const clear = () => {\n    queue.length = 0;\n    pending.clear();\n  };\n\n  return { schedule, clear };\n};\n","import { useQueryStore } from \"./client\";\n\nexport type CacheVersionGuardOptions = {\n  version: string;\n  storage?: \"local\" | \"session\";\n  channelName?: string;\n  clearOnMismatch?: boolean;\n  onMismatch?: (previous: string | null, next: string) => void;\n};\n\nexport const createCacheVersionGuard = (options: CacheVersionGuardOptions) => {\n  if (typeof window === \"undefined\") {\n    return { previousVersion: null as string | null, dispose: () => {} };\n  }\n\n  const storage =\n    options.storage === \"session\" ? window.sessionStorage : window.localStorage;\n  const persistenceKey =\n    useQueryStore.getState().config.persistence.storageKey;\n  const versionKey = `${persistenceKey}::version`;\n  const previous = storage.getItem(versionKey);\n  const next = options.version;\n  const clearOnMismatch = options.clearOnMismatch ?? true;\n\n  if (previous !== next) {\n    if (clearOnMismatch) {\n      useQueryStore.getState().clear();\n    }\n    options.onMismatch?.(previous, next);\n    storage.setItem(versionKey, next);\n  }\n\n  const channelName = options.channelName ?? \"yokai-query-cache\";\n  if (typeof BroadcastChannel === \"undefined\") {\n    return { previousVersion: previous, dispose: () => {} };\n  }\n\n  const channel = new BroadcastChannel(channelName);\n  const handler = (event: MessageEvent) => {\n    const data = event.data as { type?: string; version?: string } | undefined;\n    if (!data || data.type !== \"cache:version\") return;\n    if (data.version !== next && clearOnMismatch) {\n      useQueryStore.getState().clear();\n    }\n  };\n\n  channel.addEventListener(\"message\", handler);\n  channel.postMessage({ type: \"cache:version\", version: next });\n\n  const dispose = () => {\n    channel.removeEventListener(\"message\", handler);\n    channel.close();\n  };\n\n  return { previousVersion: previous, dispose };\n};\n","import { useQueryStore } from \"./client\";\nimport { QueryEntry, QueryKey } from \"../types\";\nimport { hashKey } from \"../utils/keys\";\n\nexport type CacheSnapshot = {\n  version: number;\n  createdAt: number;\n  entries: Record<string, Omit<QueryEntry, \"fetcher\">>;\n};\n\nexport const exportCacheSnapshot = (): CacheSnapshot => {\n  const state = useQueryStore.getState();\n  const entries: Record<string, Omit<QueryEntry, \"fetcher\">> = {};\n  Object.entries(state.queries).forEach(([key, entry]) => {\n    const { fetcher: _f, error: _e, ...rest } = entry;\n    entries[key] = rest;\n  });\n  return { version: 1, createdAt: Date.now(), entries };\n};\n\nexport const importCacheSnapshot = (snapshot: CacheSnapshot) => {\n  if (!snapshot?.entries) return;\n  const next = Object.fromEntries(\n    Object.entries(snapshot.entries).map(([k, entry]) => {\n      return [\n        k,\n        {\n          ...entry,\n          staleTime: entry.staleTime,\n          cacheTime: entry.cacheTime,\n        } as QueryEntry,\n      ];\n    })\n  );\n  useQueryStore.setState({ queries: next });\n};\n\nexport const setSnapshotEntry = (key: QueryKey, entry: QueryEntry) => {\n  const hashedKey = hashKey(key);\n  useQueryStore.setState((state) => ({\n    queries: { ...state.queries, [hashedKey]: entry },\n  }));\n};\n","import { useQueryStore } from \"../store\";\n\nexport type OfflineMutation<TVars, TResult> = {\n  key: string;\n  vars: TVars;\n  run: (vars: TVars) => Promise<TResult>;\n};\n\nexport type OfflineQueueOptions = {\n  storageKey?: string;\n  autoFlush?: boolean;\n};\n\nexport const createOfflineMutationQueue = (options: OfflineQueueOptions = {}) => {\n  const storageKey = options.storageKey ?? \"__yokai_offline_queue__\";\n  const queue: OfflineMutation<any, any>[] = [];\n\n  const load = () => {\n    if (typeof window === \"undefined\") return;\n    const raw = window.localStorage.getItem(storageKey);\n    if (!raw) return;\n    try {\n      const parsed = JSON.parse(raw) as Array<{ key: string; vars: unknown }>;\n      parsed.forEach((item) => {\n        queue.push({\n          key: item.key,\n          vars: item.vars,\n          run: async () => {\n            throw new Error(\"Offline queue item missing run()\");\n          },\n        });\n      });\n    } catch {\n      // ignore\n    }\n  };\n\n  const persist = () => {\n    if (typeof window === \"undefined\") return;\n    const snapshot = queue.map((item) => ({ key: item.key, vars: item.vars }));\n    window.localStorage.setItem(storageKey, JSON.stringify(snapshot));\n  };\n\n  const enqueue = <TVars, TResult>(\n    key: string,\n    vars: TVars,\n    run: (vars: TVars) => Promise<TResult>\n  ) => {\n    queue.push({ key, vars, run });\n    persist();\n  };\n\n  const flush = async () => {\n    const snapshot = [...queue];\n    queue.length = 0;\n    persist();\n    for (const item of snapshot) {\n      try {\n        await item.run(item.vars);\n      } catch {\n        queue.push(item);\n      }\n    }\n    persist();\n  };\n\n  if (options.autoFlush && typeof window !== \"undefined\") {\n    window.addEventListener(\"online\", () => {\n      flush().catch(() => {});\n    });\n  }\n\n  load();\n\n  return { enqueue, flush, size: () => queue.length };\n};\n","import { QueryKey } from \"../types\";\nimport { useQueryStore } from \"../store\";\nimport { hashKey } from \"../utils/keys\";\n\nexport type PresenceEntry = {\n  id: string;\n  name?: string;\n  status?: string;\n  lastSeen?: number;\n};\n\nexport type PresenceTtlOptions = {\n  key: QueryKey;\n  ttlMs: number;\n  intervalMs?: number;\n  getId?: (entry: PresenceEntry) => string;\n  onEvict?: (evicted: PresenceEntry[]) => void;\n};\n\nexport const startPresenceTtl = (options: PresenceTtlOptions) => {\n  const interval = Math.max(1000, options.intervalMs ?? 5_000);\n  const hashedKey = hashKey(options.key);\n  const getId = options.getId ?? ((entry: PresenceEntry) => entry.id);\n\n  const tick = () => {\n    const state = useQueryStore.getState();\n    const prev = state.queries[hashedKey]?.data;\n    const list = Array.isArray(prev) ? (prev as PresenceEntry[]) : [];\n    const now = Date.now();\n    const [keep, evicted] = list.reduce<\n      [PresenceEntry[], PresenceEntry[]]\n    >(\n      (acc, entry) => {\n        const lastSeen = entry.lastSeen ?? 0;\n        if (now - lastSeen <= options.ttlMs) {\n          acc[0].push(entry);\n        } else {\n          acc[1].push(entry);\n        }\n        return acc;\n      },\n      [[], []]\n    );\n\n    if (evicted.length > 0) {\n      state.setQueryData(options.key, keep, {\n        tags: state.queries[hashedKey]?.tags,\n      });\n      options.onEvict?.(evicted);\n    }\n  };\n\n  const timer = window.setInterval(tick, interval);\n  return () => window.clearInterval(timer);\n};\n","import { QueryKey } from \"../types\";\nimport { useQueryStore } from \"../store\";\nimport { hashKey } from \"../utils/keys\";\n\nexport type ReadReceipt = {\n  messageId: string;\n  userId: string;\n  readAt: number;\n};\n\nexport type ReadReceiptOptions = {\n  key: QueryKey;\n};\n\nexport const addReadReceipt = (receipt: ReadReceipt, options: ReadReceiptOptions) => {\n  const state = useQueryStore.getState();\n  const hashedKey = hashKey(options.key);\n  const prev = state.queries[hashedKey]?.data;\n  const list = Array.isArray(prev) ? (prev as ReadReceipt[]) : [];\n  const exists = list.some(\n    (item) =>\n      item.messageId === receipt.messageId && item.userId === receipt.userId\n  );\n  if (exists) return;\n  state.setQueryData(options.key, [...list, receipt], {\n    tags: state.queries[hashedKey]?.tags,\n  });\n};\n","import { QueryKey } from \"../types\";\nimport { hashKey } from \"../utils/keys\";\nimport { useQueryStore } from \"../store\";\n\nexport type SetListCacheOptions<T> = {\n  prepend?: boolean;\n  idKey?: keyof T;\n  unique?: boolean;\n  setOptions?: {\n    staleTime?: number;\n    cacheTime?: number;\n    refetchInterval?: number;\n    tags?: string[];\n    meta?: unknown;\n    fetchedAt?: number;\n  };\n};\n\nexport function setListCache<T>(\n  key: QueryKey,\n  item: T,\n  options?: SetListCacheOptions<T>\n) {\n  const state = useQueryStore.getState();\n  const hashedKey = hashKey(key);\n  const prev = state.queries[hashedKey]?.data;\n  const list = Array.isArray(prev) ? (prev as T[]) : [];\n  const next = options?.prepend ? [item, ...list] : [...list, item];\n\n  let deduped = next;\n  if (options?.idKey && options.unique !== false) {\n    const seen = new Set<unknown>();\n    deduped = next.filter((entry) => {\n      const id = entry?.[options.idKey as keyof T];\n      if (id === undefined || id === null) return true;\n      if (seen.has(id)) return false;\n      seen.add(id);\n      return true;\n    });\n  }\n\n  state.setQueryData(key, deduped, options?.setOptions);\n}\n","import { QueryClientConfigUpdate } from \"../types\";\nimport { createQueryClient } from \"../store\";\n\nexport const createDefaultClient = (overrides?: QueryClientConfigUpdate) =>\n  createQueryClient(overrides);\n","import { useEffect, useRef } from \"react\";\nimport { QueryFetcher, QueryKey, QueryDefaultOptions, RetryOptions } from \"../types\";\r\nimport { DEFAULT_CACHE_TIME, DEFAULT_STALE_TIME } from \"../store/defaults\";\r\nimport { hashKey, keyToString } from \"../utils/keys\";\r\nimport { useQueryStore } from \"../store\";\r\n\r\nexport type UseQueryReturn<T, R> = {\r\n  data: R | undefined;\r\n  error: unknown;\r\n  isLoading: boolean;\r\n  isFetching: boolean;\r\n  isStale: boolean;\r\n  refetch: (opts?: { background?: boolean }) => Promise<T | undefined>;\r\n};\r\n\r\nexport type UseQueryOptions<T, R> = {\r\n  select?: (data: T) => R;\r\n  fetcher?: QueryFetcher<T>;\r\n  enabled?: boolean;\r\n  suspense?: boolean;\r\n  throwOnError?: boolean;\r\n  background?: boolean;\r\n  keepPreviousData?: boolean;\r\n  initialData?: T | (() => T);\r\n  placeholderData?: R | ((prev: R | undefined) => R);\r\n  onSuccess?: (data: T) => void;\r\n  onError?: (error: unknown) => void;\r\n  onSettled?: (data: T | undefined, error: unknown | undefined) => void;\r\n  meta?: unknown;\r\n  staleTime?: number;\r\n  cacheTime?: number;\r\n  refetchInterval?: number;\r\n  tags?: string[];\r\n  retry?: RetryOptions;\r\n  abortOnNewFetch?: boolean;\r\n};\r\n\r\nexport function useQuery<T, R = T>(\r\n  key: QueryKey,\r\n  selectOrOptions?: ((data: T) => R) | UseQueryOptions<T, R>\r\n): UseQueryReturn<T, R> {\r\n  const resolvedKey = hashKey(key);\r\n  const options: UseQueryOptions<T, R> =\r\n    typeof selectOrOptions === \"function\"\r\n      ? { select: selectOrOptions }\r\n      : selectOrOptions ?? {};\r\n\r\n  const select = options.select;\r\n  const config = useQueryStore.getState().config;\r\n  const selectMemoMaxEntries = config.selectMemoMaxEntries ?? 0;\r\n  const defaults = (config.queryDefaults ?? []).reduce<QueryDefaultOptions>(\r\n    (acc, entry) => {\r\n      if (keyToString(key).startsWith(entry.prefix)) {\r\n        return { ...acc, ...entry.options };\r\n      }\r\n      return acc;\r\n    },\r\n    {}\r\n  );\r\n  const {\r\n    initialData: defaultInitialData,\r\n    placeholderData: defaultPlaceholderData,\r\n    ...restDefaults\r\n  } = defaults;\r\n  const mergedOptions: UseQueryOptions<T, R> = {\r\n    ...(restDefaults as Omit<UseQueryOptions<T, R>, \"initialData\" | \"placeholderData\">),\r\n    ...options,\r\n    retry: options.retry ?? defaults.retry,\r\n    tags: options.tags ?? defaults.tags,\r\n    refetchInterval: options.refetchInterval ?? defaults.refetchInterval,\r\n    abortOnNewFetch: options.abortOnNewFetch ?? defaults.abortOnNewFetch,\r\n    staleTime: options.staleTime ?? defaults.staleTime,\r\n    cacheTime: options.cacheTime ?? defaults.cacheTime,\r\n    initialData:\r\n      options.initialData ??\r\n      (defaultInitialData as T | (() => T) | undefined),\r\n    placeholderData:\r\n      options.placeholderData ??\r\n      (defaultPlaceholderData as R | ((prev: R | undefined) => R) | undefined),\r\n  };\r\n  const suspense = mergedOptions.suspense ?? config.suspense;\r\n  const throwOnError = mergedOptions.throwOnError ?? config.throwOnError;\r\n  const keepPreviousData = mergedOptions.keepPreviousData ?? false;\r\n  const previousDataRef = useRef<R | undefined>(undefined);\r\n  const previousKeyRef = useRef<string | undefined>(undefined);\n  const initialDataAppliedRef = useRef<string | undefined>(undefined);\n  const initialDataRef = useRef<{ key: string; value: T } | null>(null);\n  const fetcherRef = useRef<QueryFetcher<T> | undefined>(mergedOptions.fetcher);\n\n  const entry = useQueryStore((state) => state.queries[resolvedKey]);\n  const isFetching = useQueryStore((state) => !!state.inFlight[resolvedKey]);\n  let selected: any = entry?.data as T | undefined;\n\n  if (entry?.data !== undefined && select && selectMemoMaxEntries > 0) {\n    const memo = (useQueryStore as any).__selectMemo as\n      | Map<string, { selectRef: Function; inputRef: unknown; output: unknown }>\n      | undefined;\n\n    if (!memo) {\n      (useQueryStore as any).__selectMemo = new Map();\n    }\n    const cache = (useQueryStore as any).__selectMemo as Map<\n      string,\n      { selectRef: Function; inputRef: unknown; output: unknown }\n    >;\n\n    const prev = cache.get(resolvedKey);\n    if (prev && prev.selectRef === select && prev.inputRef === entry.data) {\n      selected = prev.output as R;\n    } else {\n      const out = select(entry.data as T);\n      cache.delete(resolvedKey);\n      cache.set(resolvedKey, {\n        selectRef: select,\n        inputRef: entry.data,\n        output: out,\n      });\n      if (selectMemoMaxEntries > 0 && cache.size > selectMemoMaxEntries) {\n        const firstKey = cache.keys().next().value;\n        if (firstKey !== undefined) cache.delete(firstKey);\n      }\n      selected = out as R;\n    }\n  }\n\n  const hasData = entry?.data !== undefined;\n  const error = entry?.error;\n  const fetchedAt = entry?.fetchedAt;\n  const staleTime = entry?.staleTime;\n  const cacheTime = entry?.cacheTime;\n  const refetchInterval = entry?.refetchInterval;\n  const tags = entry?.tags;\n  const retry = entry?.retry;\n  const entryFetcher = entry?.fetcher;\n  const now = Date.now();\n  const isStale =\n    !fetchedAt ||\n    now - fetchedAt >\n      (staleTime ?? DEFAULT_STALE_TIME);\n\r\n  useEffect(() => {\n    fetcherRef.current = mergedOptions.fetcher;\n  }, [mergedOptions.fetcher]);\n\n  useEffect(() => {\n    const enabled = mergedOptions.enabled ?? false;\n    if (!enabled) return;\n\n    const f = fetcherRef.current;\n    if (!f) return;\n\r\n    if (isFetching) return;\n\n    if (hasData && !isStale) return;\n    if (initialDataRef.current?.key === resolvedKey && !hasData) return;\n\r\n    useQueryStore\r\n      .getState()\r\n      .fetchQuery<T>(key, {\r\n        fetcher: f,\r\n        staleTime:\n          mergedOptions.staleTime ?? staleTime ?? DEFAULT_STALE_TIME,\n        cacheTime:\n          mergedOptions.cacheTime ?? cacheTime ?? DEFAULT_CACHE_TIME,\n        background: false,\n        refetchInterval:\n          mergedOptions.refetchInterval ?? refetchInterval,\n        tags: mergedOptions.tags ?? tags,\n        retry: mergedOptions.retry ?? retry,\n        abortOnNewFetch: mergedOptions.abortOnNewFetch ?? true,\n        onSuccess: mergedOptions.onSuccess,\r\n        onError: mergedOptions.onError,\r\n        onSettled: mergedOptions.onSettled,\r\n        meta: mergedOptions.meta,\r\n      })\r\n      .catch(() => {});\r\n  }, [\n    resolvedKey,\n    mergedOptions.enabled,\n    mergedOptions.staleTime,\n    mergedOptions.cacheTime,\n    mergedOptions.refetchInterval,\n    JSON.stringify(mergedOptions.tags ?? []),\n  ]);\r\n\r\n  const refetch = async (opts?: { background?: boolean }) => {\r\n    const state = useQueryStore.getState();\r\n    const q = state.queries[resolvedKey];\r\n    const fetcher = (q?.fetcher ?? mergedOptions.fetcher) as\r\n      | QueryFetcher<T>\r\n      | undefined;\r\n\r\n    if (mergedOptions.enabled === false) return undefined;\r\n\r\n    if (!fetcher) return undefined;\r\n\r\n    return state.fetchQuery<T>(key, {\n      fetcher,\n      staleTime: mergedOptions.staleTime ?? q.staleTime,\n      cacheTime: mergedOptions.cacheTime ?? q.cacheTime,\n      background: opts?.background ?? false,\n      skipStaleWhileRevalidate: true,\n      refetchInterval: mergedOptions.refetchInterval ?? q.refetchInterval,\n      tags: mergedOptions.tags ?? q.tags,\n      retry: mergedOptions.retry ?? q.retry,\n      abortOnNewFetch: mergedOptions.abortOnNewFetch ?? true,\n      onSuccess: mergedOptions.onSuccess,\n      onError: mergedOptions.onError,\r\n      onSettled: mergedOptions.onSettled,\r\n      meta: mergedOptions.meta,\r\n    });\r\n  };\r\n\r\n  if (mergedOptions.initialData !== undefined) {\r\n    if (initialDataRef.current?.key !== resolvedKey) {\r\n      const value =\r\n        typeof mergedOptions.initialData === \"function\"\r\n          ? (mergedOptions.initialData as () => T)()\r\n          : mergedOptions.initialData;\r\n      if (value !== undefined) {\r\n        initialDataRef.current = { key: resolvedKey, value };\r\n      }\r\n    }\r\n  } else if (initialDataRef.current?.key === resolvedKey) {\r\n    initialDataRef.current = null;\r\n  }\r\n\r\n  const initialDataValue =\r\n    initialDataRef.current?.key === resolvedKey\r\n      ? initialDataRef.current.value\r\n      : undefined;\r\n\r\n  useEffect(() => {\r\n    const enabled = mergedOptions.enabled ?? false;\r\n    if (!enabled) return;\r\n    if (hasData) return;\n    if (initialDataValue === undefined) return;\r\n    if (initialDataAppliedRef.current === resolvedKey) return;\r\n    useQueryStore.getState().setQueryData<T>(resolvedKey, initialDataValue, {\r\n      staleTime: mergedOptions.staleTime,\r\n      cacheTime: mergedOptions.cacheTime,\r\n      refetchInterval: mergedOptions.refetchInterval,\r\n      tags: mergedOptions.tags,\r\n      retry: mergedOptions.retry,\r\n      meta: mergedOptions.meta,\r\n    });\r\n    initialDataAppliedRef.current = resolvedKey;\r\n  }, [\r\n    resolvedKey,\r\n    mergedOptions.enabled,\r\n    mergedOptions.staleTime,\r\n    mergedOptions.cacheTime,\r\n    mergedOptions.refetchInterval,\r\n    JSON.stringify(mergedOptions.tags ?? []),\r\n    initialDataValue,\r\n  ]);\r\n\r\n  useEffect(() => {\n    if (!hasData) return;\n    previousDataRef.current = selected as R | undefined;\n    previousKeyRef.current = resolvedKey;\n  }, [resolvedKey, hasData, selected]);\n\n  let displayData = selected as R | undefined;\n  let hasDisplayData = hasData;\n\n  if (!hasData && initialDataValue !== undefined) {\n    displayData = select\r\n      ? select(initialDataValue)\r\n      : (initialDataValue as unknown as R);\r\n    hasDisplayData = true;\r\n  } else if (\r\n    !hasData &&\n    keepPreviousData &&\n    previousDataRef.current !== undefined &&\n    previousKeyRef.current !== resolvedKey\n  ) {\n    displayData = previousDataRef.current;\n    hasDisplayData = true;\n  } else if (\n    !hasData &&\n    isFetching &&\n    mergedOptions.placeholderData !== undefined\n  ) {\n    const placeholder =\r\n      typeof mergedOptions.placeholderData === \"function\"\r\n        ? (mergedOptions.placeholderData as (prev: R | undefined) => R)(\r\n            previousDataRef.current\r\n          )\r\n        : mergedOptions.placeholderData;\r\n    displayData = placeholder;\r\n    hasDisplayData = true;\r\n  }\r\n\r\n  useEffect(() => {\r\n    useQueryStore.getState().addObserver(key);\r\n    return () => {\r\n      useQueryStore.getState().removeObserver(key);\r\n    };\r\n  }, [resolvedKey]);\r\n\r\n  if (throwOnError && error) {\n    throw error;\n  }\n  if (suspense && isFetching && !hasDisplayData) {\n    const promise = useQueryStore.getState().inFlight[resolvedKey];\n    if (promise) throw promise;\n  }\n\n  return {\n    data: displayData,\n    error,\n    isLoading: isFetching && !hasDisplayData,\n    isFetching,\n    isStale,\n    refetch,\n  };\n}\n","import { useEffect, useRef } from \"react\";\r\nimport {\r\n  InfiniteData,\r\n  QueryDefaultOptions,\r\n  QueryKey,\r\n  RetryOptions,\r\n} from \"../types\";\r\nimport { DEFAULT_CACHE_TIME, DEFAULT_STALE_TIME } from \"../store/defaults\";\r\nimport { hashKey, keyToString } from \"../utils/keys\";\r\nimport { useQueryStore } from \"../store\";\r\n\r\nexport type UseInfiniteQueryOptions<TPage, TParam> = {\r\n  fetcher: (ctx: { pageParam: TParam; signal?: AbortSignal }) => Promise<TPage>;\r\n  getNextPageParam: (\r\n    lastPage: TPage,\r\n    pages: TPage[],\r\n    pageParams: TParam[]\r\n  ) => TParam | undefined;\r\n  getPreviousPageParam?: (\r\n    firstPage: TPage,\r\n    pages: TPage[],\r\n    pageParams: TParam[]\r\n  ) => TParam | undefined;\r\n  initialPageParam: TParam;\r\n  enabled?: boolean;\r\n  suspense?: boolean;\r\n  throwOnError?: boolean;\r\n  background?: boolean;\r\n  keepPreviousData?: boolean;\r\n  initialData?: InfiniteData<TPage, TParam> | (() => InfiniteData<TPage, TParam>);\r\n  placeholderData?:\r\n    | InfiniteData<TPage, TParam>\r\n    | ((prev: InfiniteData<TPage, TParam> | undefined) => InfiniteData<TPage, TParam>);\r\n  onSuccess?: (data: InfiniteData<TPage, TParam>) => void;\r\n  onError?: (error: unknown) => void;\r\n  onSettled?: (\r\n    data: InfiniteData<TPage, TParam> | undefined,\r\n    error: unknown | undefined\r\n  ) => void;\r\n  meta?: unknown;\r\n  staleTime?: number;\r\n  cacheTime?: number;\r\n  refetchInterval?: number;\r\n  tags?: string[];\r\n  retry?: RetryOptions;\r\n  abortOnNewFetch?: boolean;\r\n};\r\n\r\nexport type UseInfiniteQueryReturn<TPage, TParam> = {\r\n  data: InfiniteData<TPage, TParam> | undefined;\r\n  error: unknown;\r\n  isLoading: boolean;\r\n  isFetching: boolean;\r\n  isFetchingNextPage: boolean;\r\n  isFetchingPreviousPage: boolean;\r\n  hasNextPage: boolean;\r\n  hasPreviousPage: boolean;\r\n  fetchNextPage: () => Promise<InfiniteData<TPage, TParam> | undefined>;\r\n  fetchPreviousPage: () => Promise<InfiniteData<TPage, TParam> | undefined>;\r\n  refetch: () => Promise<InfiniteData<TPage, TParam> | undefined>;\r\n};\r\n\r\nexport function useInfiniteQuery<TPage, TParam>(\r\n  key: QueryKey,\r\n  options: UseInfiniteQueryOptions<TPage, TParam>\r\n): UseInfiniteQueryReturn<TPage, TParam> {\r\n  const resolvedKey = hashKey(key);\r\n  const config = useQueryStore.getState().config;\r\n  const defaults = (config.queryDefaults ?? []).reduce<QueryDefaultOptions>(\r\n    (acc, entry) => {\r\n      if (keyToString(key).startsWith(entry.prefix)) {\r\n        return { ...acc, ...entry.options };\r\n      }\r\n      return acc;\r\n    },\r\n    {}\r\n  );\r\n  const {\r\n    initialData: defaultInitialData,\r\n    placeholderData: defaultPlaceholderData,\r\n    ...restDefaults\r\n  } = defaults;\r\n  const mergedOptions: UseInfiniteQueryOptions<TPage, TParam> = {\r\n    ...(restDefaults as Omit<\r\n      UseInfiniteQueryOptions<TPage, TParam>,\r\n      \"initialData\" | \"placeholderData\"\r\n    >),\r\n    ...options,\r\n    retry: options.retry ?? defaults.retry,\r\n    tags: options.tags ?? defaults.tags,\r\n    refetchInterval: options.refetchInterval ?? defaults.refetchInterval,\r\n    abortOnNewFetch: options.abortOnNewFetch ?? defaults.abortOnNewFetch,\r\n    staleTime: options.staleTime ?? defaults.staleTime,\r\n    cacheTime: options.cacheTime ?? defaults.cacheTime,\r\n    initialData:\r\n      options.initialData ??\r\n      (defaultInitialData as\r\n        | InfiniteData<TPage, TParam>\r\n        | (() => InfiniteData<TPage, TParam>)\r\n        | undefined),\r\n    placeholderData:\r\n      options.placeholderData ??\r\n      (defaultPlaceholderData as\r\n        | InfiniteData<TPage, TParam>\r\n        | ((prev: InfiniteData<TPage, TParam> | undefined) => InfiniteData<TPage, TParam>)\r\n        | undefined),\r\n  };\r\n  const suspense = mergedOptions.suspense ?? config.suspense;\r\n  const throwOnError = mergedOptions.throwOnError ?? config.throwOnError;\r\n  const keepPreviousData = mergedOptions.keepPreviousData ?? false;\r\n  const previousDataRef = useRef<InfiniteData<TPage, TParam> | undefined>(\r\n    undefined\r\n  );\r\n  const previousKeyRef = useRef<string | undefined>(undefined);\n  const initialDataAppliedRef = useRef<string | undefined>(undefined);\n  const initialDataRef = useRef<{\n    key: string;\n    value: InfiniteData<TPage, TParam>;\n  } | null>(null);\n  const fetcherRef = useRef(mergedOptions.fetcher);\n\r\n  const entry = useQueryStore((state) => state.queries[resolvedKey]);\n  const isFetching = useQueryStore((state) => !!state.inFlight[resolvedKey]);\n  const data = entry?.data as InfiniteData<TPage, TParam> | undefined;\n  const error = entry?.error;\n  const hasData = entry?.data !== undefined;\n  const fetchedAt = entry?.fetchedAt;\n  const staleTime = entry?.staleTime;\n  const cacheTime = entry?.cacheTime;\n  const refetchInterval = entry?.refetchInterval;\n  const tags = entry?.tags;\n  const retry = entry?.retry;\n  const now = Date.now();\n  const isStale =\n    !fetchedAt ||\n    now - fetchedAt >\n      (staleTime ?? DEFAULT_STALE_TIME);\n\r\n  useEffect(() => {\n    fetcherRef.current = mergedOptions.fetcher;\n  }, [mergedOptions.fetcher]);\n\n  useEffect(() => {\n    const enabled = mergedOptions.enabled ?? false;\n    if (!enabled) return;\n    if (!fetcherRef.current) return;\n    if (isFetching) return;\n    if (hasData && !isStale) return;\n    if (initialDataRef.current?.key === resolvedKey && !hasData) return;\n\n    useQueryStore\n      .getState()\n      .fetchInfiniteQuery<TPage, TParam>(key, {\n        fetcher: fetcherRef.current,\n        pageParam: mergedOptions.initialPageParam,\n        direction: \"init\",\n        staleTime:\n          mergedOptions.staleTime ?? staleTime ?? DEFAULT_STALE_TIME,\n        cacheTime:\n          mergedOptions.cacheTime ?? cacheTime ?? DEFAULT_CACHE_TIME,\n        background: false,\n        refetchInterval:\n          mergedOptions.refetchInterval ?? refetchInterval,\n        tags: mergedOptions.tags ?? tags,\n        retry: mergedOptions.retry ?? retry,\n        abortOnNewFetch: mergedOptions.abortOnNewFetch ?? true,\n        onSuccess: mergedOptions.onSuccess,\r\n        onError: mergedOptions.onError,\r\n        onSettled: mergedOptions.onSettled,\r\n        meta: mergedOptions.meta,\r\n      })\r\n      .catch(() => {});\r\n  }, [\n    resolvedKey,\n    mergedOptions.enabled,\n    mergedOptions.staleTime,\n    mergedOptions.cacheTime,\n    mergedOptions.refetchInterval,\n    JSON.stringify(mergedOptions.tags ?? []),\n  ]);\n\r\n  if (mergedOptions.initialData !== undefined) {\r\n    if (initialDataRef.current?.key !== resolvedKey) {\r\n      const value =\r\n        typeof mergedOptions.initialData === \"function\"\r\n          ? (mergedOptions.initialData as () => InfiniteData<TPage, TParam>)()\r\n          : mergedOptions.initialData;\r\n      if (value !== undefined) {\r\n        initialDataRef.current = { key: resolvedKey, value };\r\n      }\r\n    }\r\n  } else if (initialDataRef.current?.key === resolvedKey) {\r\n    initialDataRef.current = null;\r\n  }\r\n\r\n  const initialDataValue =\r\n    initialDataRef.current?.key === resolvedKey\r\n      ? initialDataRef.current.value\r\n      : undefined;\r\n\r\n  useEffect(() => {\r\n    const enabled = mergedOptions.enabled ?? false;\r\n    if (!enabled) return;\r\n    if (hasData) return;\n    if (initialDataValue === undefined) return;\r\n    if (initialDataAppliedRef.current === resolvedKey) return;\r\n    useQueryStore\r\n      .getState()\r\n      .setQueryData<InfiniteData<TPage, TParam>>(resolvedKey, initialDataValue, {\r\n        staleTime: mergedOptions.staleTime,\r\n        cacheTime: mergedOptions.cacheTime,\r\n        refetchInterval: mergedOptions.refetchInterval,\r\n        tags: mergedOptions.tags,\r\n        retry: mergedOptions.retry,\r\n        meta: mergedOptions.meta,\r\n      });\r\n    initialDataAppliedRef.current = resolvedKey;\r\n  }, [\r\n    resolvedKey,\r\n    mergedOptions.enabled,\r\n    mergedOptions.staleTime,\r\n    mergedOptions.cacheTime,\r\n    mergedOptions.refetchInterval,\r\n    JSON.stringify(mergedOptions.tags ?? []),\r\n    initialDataValue,\r\n  ]);\r\n\r\n  useEffect(() => {\n    if (!hasData) return;\n    previousDataRef.current = data;\n    previousKeyRef.current = resolvedKey;\n  }, [resolvedKey, hasData, data]);\n\n  let displayData = data;\n  let hasDisplayData = hasData;\n\n  if (!hasData && initialDataValue !== undefined) {\n    displayData = initialDataValue;\n    hasDisplayData = true;\n  } else if (\n    !hasData &&\n    keepPreviousData &&\n    previousDataRef.current !== undefined &&\n    previousKeyRef.current !== resolvedKey\n  ) {\n    displayData = previousDataRef.current;\n    hasDisplayData = true;\n  } else if (\n    !hasData &&\n    isFetching &&\n    mergedOptions.placeholderData !== undefined\n  ) {\n    const placeholder =\r\n      typeof mergedOptions.placeholderData === \"function\"\r\n        ? (mergedOptions.placeholderData as (\r\n            prev: InfiniteData<TPage, TParam> | undefined\r\n          ) => InfiniteData<TPage, TParam>)(previousDataRef.current)\r\n        : mergedOptions.placeholderData;\r\n    displayData = placeholder;\n    hasDisplayData = true;\n  }\n\n  const hasNextPage =\n    !!displayData &&\n    mergedOptions.getNextPageParam(\n      displayData.pages[displayData.pages.length - 1],\n      displayData.pages,\n      displayData.pageParams\n    ) !== undefined;\n  const hasPreviousPage =\n    !!displayData &&\n    mergedOptions.getPreviousPageParam\n      ? mergedOptions.getPreviousPageParam(\n          displayData.pages[0],\n          displayData.pages,\n          displayData.pageParams\n        ) !== undefined\n      : false;\n\r\n  const fetchNextPage = async () => {\n    if (mergedOptions.enabled === false) return undefined;\n    const state = useQueryStore.getState();\n    const current = state.queries[resolvedKey]?.data as\n      | InfiniteData<TPage, TParam>\n      | undefined;\n    const pageParam = current\n      ? mergedOptions.getNextPageParam(\n          current.pages[current.pages.length - 1],\n          current.pages,\n          current.pageParams\n        )\n      : mergedOptions.initialPageParam;\n    if (pageParam === undefined) return undefined;\n    return state.fetchInfiniteQuery<TPage, TParam>(key, {\n      fetcher: fetcherRef.current,\n      pageParam,\n      direction: current ? \"forward\" : \"init\",\n      staleTime: mergedOptions.staleTime ?? staleTime,\n      cacheTime: mergedOptions.cacheTime ?? cacheTime,\n      background: false,\n      refetchInterval: mergedOptions.refetchInterval ?? refetchInterval,\n      tags: mergedOptions.tags ?? tags,\n      retry: mergedOptions.retry ?? retry,\n      abortOnNewFetch: mergedOptions.abortOnNewFetch ?? true,\n      onSuccess: mergedOptions.onSuccess,\n      onError: mergedOptions.onError,\n      onSettled: mergedOptions.onSettled,\r\n      meta: mergedOptions.meta,\r\n    });\r\n  };\r\n\r\n  const fetchPreviousPage = async () => {\n    if (mergedOptions.enabled === false) return undefined;\n    if (!mergedOptions.getPreviousPageParam) return undefined;\n    const state = useQueryStore.getState();\n    const current = state.queries[resolvedKey]?.data as\n      | InfiniteData<TPage, TParam>\n      | undefined;\n    if (!current) return undefined;\n    const pageParam = mergedOptions.getPreviousPageParam(\n      current.pages[0],\n      current.pages,\n      current.pageParams\n    );\n    if (pageParam === undefined) return undefined;\n    return state.fetchInfiniteQuery<TPage, TParam>(key, {\n      fetcher: fetcherRef.current,\n      pageParam,\n      direction: \"backward\",\n      staleTime: mergedOptions.staleTime ?? staleTime,\n      cacheTime: mergedOptions.cacheTime ?? cacheTime,\n      background: false,\n      refetchInterval: mergedOptions.refetchInterval ?? refetchInterval,\n      tags: mergedOptions.tags ?? tags,\n      retry: mergedOptions.retry ?? retry,\n      abortOnNewFetch: mergedOptions.abortOnNewFetch ?? true,\n      onSuccess: mergedOptions.onSuccess,\n      onError: mergedOptions.onError,\n      onSettled: mergedOptions.onSettled,\r\n      meta: mergedOptions.meta,\r\n    });\r\n  };\r\n\r\n  const refetch = async () => {\r\n    if (mergedOptions.enabled === false) return undefined;\r\n    const state = useQueryStore.getState();\r\n    const current = state.queries[resolvedKey]?.data as\r\n      | InfiniteData<TPage, TParam>\r\n      | undefined;\r\n    if (!current) return fetchNextPage();\r\n    try {\r\n      const result = await state.refetchInfiniteQuery<TPage, TParam>(key);\r\n      if (result) {\r\n        mergedOptions.onSuccess?.(result);\r\n        mergedOptions.onSettled?.(result, undefined);\r\n      }\r\n      return result;\r\n    } catch (error) {\r\n      mergedOptions.onError?.(error);\r\n      mergedOptions.onSettled?.(undefined, error);\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    useQueryStore.getState().addObserver(key);\r\n    return () => {\r\n      useQueryStore.getState().removeObserver(key);\r\n    };\r\n  }, [resolvedKey]);\r\n\r\n  if (throwOnError && error) {\n    throw error;\n  }\n  if (suspense && isFetching && !hasDisplayData) {\n    const promise = useQueryStore.getState().inFlight[resolvedKey];\n    if (promise) throw promise;\n  }\n\r\n  const inFlightDirection = useQueryStore\r\n    .getState()\r\n    .getInFlightDirection(resolvedKey);\r\n\r\n  return {\n    data: displayData,\n    error,\n    isLoading: isFetching && !hasDisplayData,\n    isFetching,\n    isFetchingNextPage:\n      isFetching && inFlightDirection === \"forward\",\n    isFetchingPreviousPage:\n      isFetching && inFlightDirection === \"backward\",\n    hasNextPage,\n    hasPreviousPage,\n    fetchNextPage,\n    fetchPreviousPage,\r\n    refetch,\r\n  };\r\n}\r\n","import { useCallback, useState } from \"react\";\nimport { MutateOptions } from \"../types\";\nimport { useQueryStore } from \"../store\";\n\nexport type UseMutationOptions<TVars, TResult> = Omit<\n  MutateOptions<TVars, TResult>,\n  \"variables\"\n> & {\n  onSettled?: (\n    result: TResult | undefined,\n    error: unknown | undefined,\n    vars: TVars\n  ) => void;\n};\n\nexport function useMutation<TVars, TResult>(\n  opts: UseMutationOptions<TVars, TResult>\n): {\n  mutate: (variables: TVars) => Promise<TResult>;\n  isLoading: boolean;\n  error: unknown;\n  data: TResult | undefined;\n  reset: () => void;\n  cancel: () => void;\n  status: \"idle\" | \"loading\" | \"success\" | \"error\";\n} {\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<unknown>(undefined);\n  const [data, setData] = useState<TResult | undefined>(undefined);\n\n  const mutate = useCallback(\n    async (variables: TVars) => {\n      setIsLoading(true);\n      setError(undefined);\n\n      try {\n        const result = await useQueryStore.getState().mutate<TVars, TResult>({\n          ...opts,\n          variables,\n          onSuccess: (r, v) => {\n            opts.onSuccess?.(r, v);\n          },\n          onError: (e, v) => {\n            opts.onError?.(e, v);\n          },\n        });\n\n        setData(result);\n        opts.onSettled?.(result, undefined, variables);\n        return result;\n      } catch (e) {\n        setError(e);\n        opts.onSettled?.(undefined, e, variables);\n        throw e;\n      } finally {\n        setIsLoading(false);\n      }\n    },\n    [opts]\n  );\n\n  const reset = useCallback(() => {\n    setIsLoading(false);\n    setError(undefined);\n    setData(undefined);\n  }, []);\n\n  const cancel = useCallback(() => {\n    if (opts.mutationKey) {\n      useQueryStore.getState().cancelMutation(opts.mutationKey);\n    }\n  }, [opts.mutationKey]);\n\n  const status: \"idle\" | \"loading\" | \"success\" | \"error\" = isLoading\n    ? \"loading\"\n    : error\n      ? \"error\"\n      : data !== undefined\n        ? \"success\"\n        : \"idle\";\n\n  return { mutate, isLoading, error, data, reset, cancel, status };\n}\r\n","import { QueryFetcher, QueryKey } from \"../types\";\nimport {\n  UseInfiniteQueryOptions,\n  UseInfiniteQueryReturn,\n  useInfiniteQuery,\n} from \"../hooks/useInfiniteQuery\";\nimport { UseMutationOptions, useMutation } from \"../hooks/useMutation\";\nimport { UseQueryOptions, UseQueryReturn, useQuery } from \"../hooks/useQuery\";\n\nexport type { UseInfiniteQueryOptions, UseInfiniteQueryReturn } from \"../hooks/useInfiniteQuery\";\nexport type { UseMutationOptions } from \"../hooks/useMutation\";\nexport type { UseQueryOptions, UseQueryReturn } from \"../hooks/useQuery\";\n\nexport function useSimpleQuery<T, R = T>(\n  key: QueryKey,\n  fetcher: QueryFetcher<T>,\n  options?: Omit<UseQueryOptions<T, R>, \"fetcher\">\n): UseQueryReturn<T, R> {\n  return useQuery<T, R>(key, {\n    ...options,\n    fetcher,\n    enabled: options?.enabled ?? true,\n    keepPreviousData: options?.keepPreviousData ?? true,\n  });\n}\n\nexport function useSimpleMutation<TVars, TResult>(\n  mutationFn: (vars: TVars) => Promise<TResult>,\n  options?: Omit<UseMutationOptions<TVars, TResult>, \"mutationFn\">\n) {\n  return useMutation<TVars, TResult>({\n    ...options,\n    mutationFn,\n  });\n}\n\nexport function useSimpleInfiniteQuery<TPage, TParam = unknown>(\n  key: QueryKey,\n  fetcher: (ctx: { pageParam: TParam }) => Promise<TPage>,\n  options: Omit<UseInfiniteQueryOptions<TPage, TParam>, \"fetcher\">\n): UseInfiniteQueryReturn<TPage, TParam> {\n  return useInfiniteQuery<TPage, TParam>(key, {\n    ...options,\n    fetcher,\n    enabled: options.enabled ?? true,\n  });\n}\n"],"mappings":"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","names":["out","sleep","runWithRetry","runWithRetry","existing","options","entry","useEffect","useRef","entry","useRef","useEffect","error"]}