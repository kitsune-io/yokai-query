{"version":3,"sources":["../src/index.ts","../src/api.ts","../src/auth/token.ts","../src/api/client.ts","../src/store/client.ts","../src/store/defaults.ts","../src/utils/keys.ts","../src/utils/equality.ts","../src/utils/retry.ts","../src/storage/idb.ts","../src/auth/betterAuth.ts","../src/auth/simple.ts","../src/realtime/socket.ts","../src/realtime/sse.ts","../src/realtime/chat.ts","../src/realtime/webrtc.ts","../src/observability/devtools.ts","../src/observability/tracing.ts","../src/prefetch/scheduler.ts","../src/store/versioning.ts","../src/store/snapshot.ts","../src/mutations/offlineQueue.ts","../src/realtime/presence.ts","../src/realtime/readReceipts.ts","../src/simple/cache.ts","../src/simple/store.ts","../src/hooks/useQuery.ts","../src/hooks/useInfiniteQuery.ts","../src/hooks/useMutation.ts","../src/simple/hooks.ts"],"sourcesContent":["export { api } from \"./api\";\r\nexport { createApiClient } from \"./api/client\";\r\nexport { createAuthBridgeFromEnv } from \"./auth/simple\";\r\nexport { createBetterAuthBridge } from \"./auth/betterAuth\";\r\nexport { clearAuthToken, getAuthToken, setAuthToken } from \"./auth/token\";\r\nexport { createSocketCacheBridge, connectSocketCache } from \"./realtime/socket\";\r\nexport { createSseCacheBridge, connectSseCache } from \"./realtime/sse\";\r\nexport { createChatRoomBridge } from \"./realtime/chat\";\r\nexport { createWebRtcPeer } from \"./realtime/webrtc\";\r\nexport { createStoreEventReporter } from \"./observability/devtools\";\r\nexport { wrapFetcher } from \"./observability/tracing\";\r\nexport { createPrefetchScheduler } from \"./prefetch/scheduler\";\r\nexport { createCacheVersionGuard } from \"./store/versioning\";\r\nexport { exportCacheSnapshot, importCacheSnapshot } from \"./store/snapshot\";\r\nexport { createOfflineMutationQueue } from \"./mutations/offlineQueue\";\r\nexport { startPresenceTtl } from \"./realtime/presence\";\r\nexport { addReadReceipt } from \"./realtime/readReceipts\";\r\nexport { setListCache } from \"./simple/cache\";\r\nexport { createDefaultClient } from \"./simple/store\";\r\nexport { createQueryClient, useQueryStore } from \"./store\";\r\nexport { useQuery, useInfiniteQuery, useMutation } from \"./hooks\";\r\nexport {\r\n  useSimpleInfiniteQuery,\r\n  useSimpleMutation,\r\n  useSimpleQuery,\r\n} from \"./simple/hooks\";\r\nexport type {\r\n  FetchInfiniteQueryOptions,\r\n  FetchQueryOptions,\r\n  InfiniteData,\r\n  Metrics,\r\n  MutationDefaultOptions,\r\n  MutationDefaults,\r\n  MutationState,\r\n  MutateOptions,\r\n  PersistenceMode,\r\n  QueryClientConfig,\r\n  QueryClientConfigUpdate,\r\n  QueryDefaultOptions,\r\n  QueryDefaults,\r\n  QueryEntry,\r\n  QueryFetcher,\r\n  QueryKey,\r\n  QueryKeyHash,\r\n  QueryStore,\r\n  RetryOptions,\r\n} from \"./types\";\r\nexport type {\r\n  ConnectSocketCacheOptions,\r\n  SocketCacheBridgeOptions,\r\n  SocketCacheConnection,\r\n  SocketCacheEvent,\r\n  SocketLike,\r\n} from \"./realtime/socket\";\r\nexport type { ChatBridgeOptions } from \"./realtime/chat\";\r\nexport type { SignalingTransport, WebRtcPeerOptions, WebRtcSignal } from \"./realtime/webrtc\";\r\nexport type {\r\n  ConnectSseCacheOptions,\r\n  EventSourceLike,\r\n  SseCacheBridgeOptions,\r\n  SseCacheConnection,\r\n  SseCacheEvent,\r\n} from \"./realtime/sse\";\r\nexport type { AuthBridgeFromEnvOptions } from \"./auth/simple\";\r\nexport type { ApiClientOptions, ApiPlugin, ApiRetryRule } from \"./api/client\";\r\nexport type { StoreEventDetail, StoreEventReporterOptions } from \"./observability/devtools\";\r\nexport type { FetchTrace, FetchTraceHandlers } from \"./observability/tracing\";\r\nexport type { PrefetchSchedulerOptions, PrefetchTask } from \"./prefetch/scheduler\";\r\nexport type { CacheVersionGuardOptions } from \"./store/versioning\";\r\nexport type { CacheSnapshot } from \"./store/snapshot\";\r\nexport type { OfflineMutation, OfflineQueueOptions } from \"./mutations/offlineQueue\";\r\nexport type { PresenceEntry, PresenceTtlOptions } from \"./realtime/presence\";\r\nexport type { ReadReceipt, ReadReceiptOptions } from \"./realtime/readReceipts\";\r\nexport type { SetListCacheOptions } from \"./simple/cache\";\r\nexport type {\r\n  UseInfiniteQueryOptions,\r\n  UseInfiniteQueryReturn,\r\n  UseMutationOptions,\r\n  UseQueryOptions,\r\n  UseQueryReturn,\r\n} from \"./hooks\";\r\nexport type {\r\n  UseInfiniteQueryOptions as UseSimpleInfiniteQueryOptions,\r\n  UseInfiniteQueryReturn as UseSimpleInfiniteQueryReturn,\r\n  UseMutationOptions as UseSimpleMutationOptions,\r\n  UseQueryOptions as UseSimpleQueryOptions,\r\n  UseQueryReturn as UseSimpleQueryReturn,\r\n} from \"./simple/hooks\";\r\n","import { createFetch } from \"@better-fetch/fetch\";\r\nimport { getAuthToken } from \"./auth/token\";\r\n\r\nexport const api = createFetch({\r\n  baseURL: \"/api\",\r\n  throw: true,\r\n  auth: {\r\n    type: \"Bearer\",\r\n    token: () => getAuthToken(),\r\n  },\r\n  retry: {\r\n    type: \"linear\",\r\n    attempts: 3,\r\n    delay: 300,\r\n  },\r\n});\r\n","let authToken: string | undefined;\r\n\r\nexport const setAuthToken = (token?: string) => {\r\n  authToken = token;\r\n};\r\n\r\nexport const clearAuthToken = () => {\r\n  authToken = undefined;\r\n};\r\n\r\nexport const getAuthToken = () => authToken;\r\n","import { RetryOptions } from \"../types\";\r\nimport { getAuthToken } from \"../auth/token\";\r\n\r\nexport type ApiPlugin = {\r\n  onRequest?: (input: RequestInfo, init: RequestInit) => void;\r\n  onResponse?: (response: Response) => void;\r\n  onError?: (error: unknown) => void;\r\n};\r\n\r\nexport type ApiRetryRule = {\r\n  prefix: string;\r\n  retry: RetryOptions;\r\n};\r\n\r\nexport type ApiClientOptions = {\r\n  baseURL?: string;\r\n  getAuthToken?: () => string | undefined;\r\n  defaultRetry?: RetryOptions;\r\n  retryRules?: ApiRetryRule[];\r\n  plugins?: ApiPlugin[];\r\n};\r\n\r\nconst resolveRetry = (path: string, rules?: ApiRetryRule[]) => {\r\n  if (!rules) return undefined;\r\n  const matched = rules.find((rule) => path.startsWith(rule.prefix));\r\n  return matched?.retry;\r\n};\r\n\r\nconst sleep = (ms: number) =>\r\n  new Promise<void>((resolve) => setTimeout(resolve, ms));\r\n\r\nconst runWithRetry = async <T>(\r\n  fn: () => Promise<T>,\r\n  retryCfg?: RetryOptions\r\n): Promise<T> => {\r\n  const cfg = retryCfg ?? { attempts: 1 };\r\n  const attempts = Math.max(1, cfg.attempts ?? 1);\r\n  const retryOn = cfg.retryOn ?? (() => true);\r\n  const delayCfg = cfg.delay ?? 0;\r\n\r\n  let lastErr: unknown;\r\n\r\n  for (let i = 0; i < attempts; i += 1) {\r\n    try {\r\n      return await fn();\r\n    } catch (err) {\r\n      lastErr = err;\r\n      if (i === attempts - 1) break;\r\n      if (!retryOn(err, i + 1)) break;\r\n      const ms =\r\n        typeof delayCfg === \"function\" ? delayCfg(i + 1) : delayCfg;\r\n      if (ms > 0) await sleep(ms);\r\n    }\r\n  }\r\n\r\n  throw lastErr;\r\n};\r\n\r\nexport const createApiClient = (options: ApiClientOptions = {}) => {\r\n  const baseURL = options.baseURL ?? \"/api\";\r\n  const tokenFn = options.getAuthToken ?? getAuthToken;\r\n  const plugins = options.plugins ?? [];\r\n\r\n  const request = async <T = unknown>(\r\n    path: string,\r\n    init: RequestInit = {}\r\n  ): Promise<T> => {\r\n    const url = `${baseURL}${path}`;\r\n    const headers = new Headers(init.headers ?? {});\r\n    const token = tokenFn();\r\n    if (token) {\r\n      headers.set(\"Authorization\", `Bearer ${token}`);\r\n    }\r\n\r\n    const finalInit: RequestInit = { ...init, headers };\r\n    plugins.forEach((p) => p.onRequest?.(url, finalInit));\r\n\r\n    const retryCfg =\r\n      resolveRetry(path, options.retryRules) ?? options.defaultRetry;\r\n\r\n    return runWithRetry(async () => {\r\n      try {\r\n        const res = await fetch(url, finalInit);\r\n        plugins.forEach((p) => p.onResponse?.(res));\r\n        if (!res.ok) {\r\n          throw new Error(`HTTP ${res.status}`);\r\n        }\r\n        return (await res.json()) as T;\r\n      } catch (err) {\r\n        plugins.forEach((p) => p.onError?.(err));\r\n        throw err;\r\n      }\r\n    }, retryCfg);\r\n  };\r\n\r\n  return {\r\n    request,\r\n    get: <T = unknown>(path: string, init?: RequestInit) =>\r\n      request<T>(path, { ...init, method: \"GET\" }),\r\n    post: <T = unknown>(path: string, body?: unknown, init?: RequestInit) =>\r\n      request<T>(path, {\r\n        ...init,\r\n        method: \"POST\",\r\n        body: body !== undefined ? JSON.stringify(body) : undefined,\r\n        headers: { \"Content-Type\": \"application/json\", ...(init?.headers ?? {}) },\r\n      }),\r\n    put: <T = unknown>(path: string, body?: unknown, init?: RequestInit) =>\r\n      request<T>(path, {\r\n        ...init,\r\n        method: \"PUT\",\r\n        body: body !== undefined ? JSON.stringify(body) : undefined,\r\n        headers: { \"Content-Type\": \"application/json\", ...(init?.headers ?? {}) },\r\n      }),\r\n    patch: <T = unknown>(path: string, body?: unknown, init?: RequestInit) =>\r\n      request<T>(path, {\r\n        ...init,\r\n        method: \"PATCH\",\r\n        body: body !== undefined ? JSON.stringify(body) : undefined,\r\n        headers: { \"Content-Type\": \"application/json\", ...(init?.headers ?? {}) },\r\n      }),\r\n    delete: <T = unknown>(path: string, init?: RequestInit) =>\r\n      request<T>(path, { ...init, method: \"DELETE\" }),\r\n  };\r\n};\r\n","\r\nimport { create } from \"zustand\";\r\nimport {\r\n  FetchInfiniteQueryOptions,\r\n  FetchQueryOptions,\r\n  InfiniteData,\r\n  MutationDefaultOptions,\r\n  MutateOptions,\r\n  QueryClientConfig,\r\n  QueryClientConfigUpdate,\r\n  QueryDefaultOptions,\r\n  QueryEntry,\r\n  QueryFetcher,\r\n  QueryKey,\r\n  QueryKeyHash,\r\n  QueryStore,\r\n  Metrics,\r\n} from \"../types\";\r\nimport {\r\n  DEFAULT_CACHE_TIME,\r\n  DEFAULT_STALE_TIME,\r\n  createMetrics,\r\n  defaultConfig,\r\n} from \"./defaults\";\r\nimport { hashKey, keyToString } from \"../utils/keys\";\r\nimport { replaceEqualDeep } from \"../utils/equality\";\r\nimport { isAbortError, runWithRetry } from \"../utils/retry\";\r\nimport { idbGet, idbSet } from \"../storage/idb\";\r\n\r\nexport function createQueryClient(userConfig?: QueryClientConfigUpdate) {\r\n  const { multiTabSync: multiTabSyncOverride, ...userOverrides } =\r\n    userConfig ?? {};\r\n  const cfg: QueryClientConfig = {\r\n    ...defaultConfig,\r\n    ...userOverrides,\r\n    persistence: {\r\n      ...defaultConfig.persistence,\r\n      ...(userOverrides.persistence ?? {}),\r\n    },\r\n    retry: {\r\n      ...defaultConfig.retry,\r\n      ...(userOverrides.retry ?? {}),\r\n    },\r\n    multiTabSync: {\r\n      ...defaultConfig.multiTabSync,\r\n      ...(multiTabSyncOverride ?? {}),\r\n    },\r\n    devtools: {\r\n      ...defaultConfig.devtools,\r\n      ...(userOverrides.devtools ?? {}),\r\n    },\r\n  };\r\n\r\n  const fetchers = new Map<QueryKeyHash, QueryFetcher<unknown>>();\r\n  const infiniteFetchers = new Map<\r\n    QueryKeyHash,\r\n    (ctx: { pageParam: unknown; signal?: AbortSignal }) => Promise<unknown>\r\n  >();\r\n  const keyMap = new Map<QueryKeyHash, QueryKey>();\r\n  const resolveKey = (hashedKey: QueryKeyHash): QueryKey =>\r\n    keyMap.get(hashedKey) ?? hashedKey;\r\n\r\n  const pollers = new Map<QueryKeyHash, { timer: number; interval: number }>();\r\n\r\n  const selectMemo = new Map<\r\n    QueryKeyHash,\r\n    { selectRef: Function; inputRef: unknown; output: unknown }\r\n  >();\r\n\r\n  const tagIndex = new Map<string, Set<QueryKeyHash>>();\r\n\r\n  const aborters = new Map<QueryKeyHash, AbortController>();\r\n  const mutationAborters = new Map<QueryKeyHash, AbortController>();\r\n  const observers = new Map<QueryKeyHash, number>();\r\n  const inFlightMeta = new Map<\r\n    QueryKeyHash,\r\n    { direction?: \"forward\" | \"backward\" | \"init\" }\r\n  >();\r\n\r\n  let batchDepth = 0;\r\n  let pendingQueries: Record<QueryKeyHash, QueryEntry> | null = null;\r\n  let flushRequested = false;\r\n\r\n  let flushTimer: number | null = null;\r\n\r\n  const isBrowser = typeof window !== \"undefined\";\r\n  const instanceId = Math.random().toString(36).slice(2);\r\n  const channel =\r\n    isBrowser &&\r\n    cfg.multiTabSync.enabled &&\r\n    typeof BroadcastChannel !== \"undefined\"\r\n      ? new BroadcastChannel(cfg.multiTabSync.channelName)\r\n      : null;\r\n  let suppressBroadcast = false;\r\n  const broadcast = (message: { type: string; payload?: unknown }) => {\r\n    if (!channel || suppressBroadcast) return;\r\n    channel.postMessage({ ...message, sourceId: instanceId });\r\n  };\r\n  const getQueryDefaultOptions = (\r\n    key: QueryKey,\r\n    config: QueryClientConfig\r\n  ): QueryDefaultOptions => {\r\n    const keyStr = keyToString(key);\r\n    const defaults = config.queryDefaults ?? [];\r\n    let merged: QueryDefaultOptions = {};\r\n    defaults.forEach((entry) => {\r\n      if (keyStr.startsWith(entry.prefix)) {\r\n        merged = { ...merged, ...entry.options };\r\n      }\r\n    });\r\n    return merged;\r\n  };\r\n  const getMutationDefaultOptions = (\r\n    key: QueryKey | undefined,\r\n    config: QueryClientConfig\r\n  ): MutationDefaultOptions => {\r\n    if (!key) return {};\r\n    const keyStr = keyToString(key);\r\n    const defaults = config.mutationDefaults ?? [];\r\n    let merged: MutationDefaultOptions = {};\r\n    defaults.forEach((entry) => {\r\n      if (keyStr.startsWith(entry.key)) {\r\n        merged = { ...merged, ...entry.options };\r\n      }\r\n    });\r\n    return merged;\r\n  };\r\n  const applyStructuralSharing = <T>(prev: T | undefined, next: T): T => {\r\n    if (!cfg.structuralSharing) return next;\r\n    if (prev === undefined) return next;\r\n    if (next === undefined) return next;\r\n    return replaceEqualDeep(prev, next);\r\n  };\r\n\r\n  const store = create<QueryStore>((set, get) => ({\r\n    config: cfg,\r\n\r\n    queries: {},\r\n    inFlight: {},\r\n    mutations: {},\r\n\r\n    metrics: createMetrics(),\r\n\r\n    dehydrate() {\r\n      return serializeQueries(get().queries);\r\n    },\r\n\r\n    hydrate(data) {\r\n      set({\r\n        queries: Object.fromEntries(\r\n          Object.entries(data).map(([k, q]) => [\r\n            k,\r\n            {\r\n              ...q,\r\n              staleTime: q.staleTime ?? DEFAULT_STALE_TIME,\r\n              cacheTime: q.cacheTime ?? DEFAULT_CACHE_TIME,\r\n              tags: q.tags ?? [],\r\n              retry: q.retry,\r\n              keyString: q.keyString ?? k,\r\n            } satisfies QueryEntry,\r\n          ])\r\n        ),\r\n      });\r\n\r\n      tagIndex.clear();\r\n      selectMemo.clear();\r\n      Object.entries(get().queries).forEach(([k, q]) => {\r\n        keyMap.set(k, k);\r\n        (q.tags ?? []).forEach((t) => {\r\n          if (!tagIndex.has(t)) tagIndex.set(t, new Set());\r\n          tagIndex.get(t)!.add(k);\r\n        });\r\n      });\r\n\r\n      if (isBrowser) {\r\n        Object.entries(get().queries).forEach(([k, q]) => {\r\n          ensurePoller(k, q.refetchInterval);\r\n        });\r\n      }\r\n\r\n      devtoolsEmit(\"hydrate\", { keys: Object.keys(get().queries) });\r\n    },\r\n\r\n    async fetchQuery<T>(key: QueryKey, options: FetchQueryOptions<T>) {\r\n      const hashedKey = hashKey(key);\r\n      keyMap.set(hashedKey, key);\r\n      const defaults = getQueryDefaultOptions(key, get().config);\r\n      const {\r\n        suspense: _s,\r\n        throwOnError: _t,\r\n        keepPreviousData: _k,\r\n        initialData: _i,\r\n        placeholderData: _p,\r\n        ...fetchDefaults\r\n      } = defaults;\r\n      const mergedOptions: FetchQueryOptions<T> = {\r\n        ...fetchDefaults,\r\n        ...options,\r\n        retry: options.retry ?? defaults.retry,\r\n        tags: options.tags ?? defaults.tags,\r\n        refetchInterval: options.refetchInterval ?? defaults.refetchInterval,\r\n        abortOnNewFetch: options.abortOnNewFetch ?? defaults.abortOnNewFetch,\r\n        background: options.background ?? defaults.background,\r\n        skipStaleWhileRevalidate: options.skipStaleWhileRevalidate ?? false,\r\n        staleTime: options.staleTime ?? defaults.staleTime,\r\n        cacheTime: options.cacheTime ?? defaults.cacheTime,\r\n      };\r\n      const {\r\n        fetcher,\r\n        staleTime = DEFAULT_STALE_TIME,\r\n        cacheTime = DEFAULT_CACHE_TIME,\r\n        background = false,\r\n        skipStaleWhileRevalidate = false,\r\n        meta,\r\n        refetchInterval,\r\n        tags,\r\n        retry,\r\n        abortOnNewFetch = true,\r\n        onSuccess,\r\n        onError,\r\n        onSettled,\r\n      } = mergedOptions;\r\n\r\n      fetchers.set(hashedKey, fetcher as QueryFetcher<unknown>);\r\n\r\n      setEntry(hashedKey, {\r\n        staleTime,\r\n        cacheTime,\r\n        fetcher,\r\n        refetchInterval,\r\n        tags: tags ?? get().queries[hashedKey]?.tags ?? [],\r\n        retry: retry ?? get().queries[hashedKey]?.retry,\r\n        meta: meta ?? get().queries[hashedKey]?.meta,\r\n        keyString: get().queries[hashedKey]?.keyString ?? keyToString(key),\r\n      });\r\n\r\n      syncTagsIndex(hashedKey, tags);\r\n\r\n      ensurePoller(hashedKey, refetchInterval);\r\n\r\n      const state = get();\r\n      const entry = state.queries[hashedKey];\r\n      const now = Date.now();\r\n\r\n      const isStale =\r\n        !entry?.fetchedAt ||\r\n        now - entry.fetchedAt > (entry?.staleTime ?? staleTime);\r\n\r\n      if (entry?.data !== undefined && !isStale) {\r\n        bump({ hits: 1 });\r\n        touch(hashedKey);\r\n        debugLog(\"hit\", hashedKey);\r\n        devtoolsEmit(\"hit\", { key: hashedKey });\r\n        return entry.data as T;\r\n      }\r\n\r\n      if (state.inFlight[hashedKey]) {\r\n        bump({ dedupes: 1 });\r\n        debugLog(\"dedupe\", hashedKey);\r\n        devtoolsEmit(\"dedupe\", { key: hashedKey });\r\n        return state.inFlight[hashedKey] as Promise<T>;\r\n      }\r\n\r\n      const shouldBackground =\r\n        entry?.data !== undefined &&\r\n        isStale &&\r\n        !skipStaleWhileRevalidate &&\r\n        (background || get().config.staleWhileRevalidate);\r\n      if (shouldBackground) {\r\n        if (get().inFlight[hashedKey]) {\r\n          bump({ dedupes: 1, backgroundFetches: 1 });\r\n          debugLog(\"dedupe\", hashedKey);\r\n          devtoolsEmit(\"dedupe\", { key: hashedKey });\r\n          return entry.data as T;\r\n        }\r\n        bump({ hits: 1, backgroundFetches: 1 });\r\n        debugLog(\"stale-hit+bg\", hashedKey);\r\n        devtoolsEmit(\"stale-hit+bg\", { key: hashedKey });\r\n\r\n        const originalKey = resolveKey(hashedKey);\r\n        get()\r\n          .fetchQuery(originalKey, {\r\n            ...mergedOptions,\r\n            background: false,\r\n            skipStaleWhileRevalidate: true,\r\n          })\r\n          .catch(() => {});\r\n        touch(hashedKey);\r\n        return entry.data as T;\r\n      }\r\n\r\n      if (abortOnNewFetch) {\r\n        get().abort(hashedKey);\r\n      }\r\n\r\n      bump({ misses: 1, fetches: 1 });\r\n      debugLog(\"miss(fetch)\", hashedKey);\r\n      devtoolsEmit(\"miss(fetch)\", { key: hashedKey });\r\n\r\n      const controller = isBrowser ? new AbortController() : undefined;\r\n      if (controller) aborters.set(hashedKey, controller);\r\n\r\n      const promise = (async () => {\r\n        try {\r\n          const data = await runWithRetry<T>(\r\n            async (attemptIndex) => {\r\n              if (controller?.signal?.aborted) {\r\n                throw (\r\n                  controller.signal.reason ??\r\n                  new DOMException(\"Aborted\", \"AbortError\")\r\n                );\r\n              }\r\n\r\n              const f = fetcher as any;\r\n              const maybePromise =\r\n                typeof f === \"function\" && f.length >= 1\r\n                  ? (f({ signal: controller?.signal }) as Promise<T>)\r\n                  : (f() as Promise<T>);\r\n\r\n              return await maybePromise;\r\n            },\r\n            retry ?? entry?.retry ?? get().config.retry,\r\n            (n) => bump({ retries: n }),\r\n            (attempt, attempts) => devtoolsEmit(\"retry\", { attempt, attempts })\r\n          );\r\n\r\n          setEntry(hashedKey, {\r\n            data,\r\n            error: undefined,\r\n            fetchedAt: Date.now(),\r\n            accessedAt: Date.now(),\r\n            staleTime,\r\n            cacheTime,\r\n            refetchInterval,\r\n            fetcher,\r\n            tags: tags ?? get().queries[hashedKey]?.tags ?? [],\r\n            retry: retry ?? get().queries[hashedKey]?.retry,\r\n            meta: meta ?? get().queries[hashedKey]?.meta,\r\n            keyString: get().queries[hashedKey]?.keyString ?? keyToString(key),\r\n          });\r\n\r\n          evictLRUIfNeeded();\r\n\r\n          scheduleFlush();\r\n          devtoolsEmit(\"fetch:success\", { key: hashedKey });\r\n          onSuccess?.(data);\r\n          onSettled?.(data, undefined);\r\n          return data;\r\n        } catch (error) {\r\n          if (isAbortError(error)) {\r\n            bump({ aborts: 1 });\r\n            setEntry(hashedKey, {\r\n              error,\r\n              fetchedAt: Date.now(),\r\n              fetcher,\r\n              lastAbortAt: Date.now(),\r\n              meta: meta ?? get().queries[hashedKey]?.meta,\r\n              keyString:\r\n                get().queries[hashedKey]?.keyString ?? keyToString(key),\r\n            });\r\n            scheduleFlush();\r\n            devtoolsEmit(\"fetch:abort\", { key: hashedKey });\r\n            throw error;\r\n          }\r\n\r\n          bump({ errors: 1 });\r\n          setEntry(hashedKey, {\r\n            error,\r\n            fetchedAt: Date.now(),\r\n            fetcher,\r\n            meta: meta ?? get().queries[hashedKey]?.meta,\r\n            keyString: get().queries[hashedKey]?.keyString ?? keyToString(key),\r\n          });\r\n          scheduleFlush();\r\n          devtoolsEmit(\"fetch:error\", { key: hashedKey });\r\n          onError?.(error);\r\n          onSettled?.(undefined, error);\r\n          throw error;\r\n        } finally {\r\n          set((s) => {\r\n            const next = { ...s.inFlight };\r\n            delete next[hashedKey];\r\n            return { inFlight: next };\r\n          });\r\n\r\n          if (controller && aborters.get(hashedKey) === controller) {\r\n            aborters.delete(hashedKey);\r\n          }\r\n        }\r\n      })();\r\n\r\n      set((s) => ({ inFlight: { ...s.inFlight, [hashedKey]: promise } }));\r\n      return promise;\r\n    },\r\n\r\n    async fetchInfiniteQuery<TPage, TParam>(\r\n      key: QueryKey,\r\n      options: FetchInfiniteQueryOptions<TPage, TParam>\r\n    ) {\r\n      const hashedKey = hashKey(key);\r\n      keyMap.set(hashedKey, key);\r\n      const defaults = getQueryDefaultOptions(key, get().config);\r\n      const {\r\n        suspense: _s,\r\n        throwOnError: _t,\r\n        keepPreviousData: _k,\r\n        initialData: _i,\r\n        placeholderData: _p,\r\n        ...fetchDefaults\r\n      } = defaults;\r\n      const mergedOptions: FetchInfiniteQueryOptions<TPage, TParam> = {\r\n        ...fetchDefaults,\r\n        ...options,\r\n        retry: options.retry ?? defaults.retry,\r\n        tags: options.tags ?? defaults.tags,\r\n        refetchInterval: options.refetchInterval ?? defaults.refetchInterval,\r\n        abortOnNewFetch: options.abortOnNewFetch ?? defaults.abortOnNewFetch,\r\n        background: options.background ?? defaults.background,\r\n        staleTime: options.staleTime ?? defaults.staleTime,\r\n        cacheTime: options.cacheTime ?? defaults.cacheTime,\r\n      };\r\n\r\n      const {\r\n        fetcher,\r\n        pageParam,\r\n        direction = \"init\",\r\n        staleTime = DEFAULT_STALE_TIME,\r\n        cacheTime = DEFAULT_CACHE_TIME,\r\n        background = false,\r\n        meta,\r\n        refetchInterval,\r\n        tags,\r\n        retry,\r\n        abortOnNewFetch = true,\r\n        onSuccess,\r\n        onError,\r\n        onSettled,\r\n      } = mergedOptions;\r\n\r\n      infiniteFetchers.set(\r\n        hashedKey,\r\n        fetcher as (ctx: { pageParam: unknown; signal?: AbortSignal }) =>\r\n          Promise<unknown>\r\n      );\r\n\r\n      setEntry(hashedKey, {\r\n        staleTime,\r\n        cacheTime,\r\n        refetchInterval,\r\n        tags: tags ?? get().queries[hashedKey]?.tags ?? [],\r\n        retry: retry ?? get().queries[hashedKey]?.retry,\r\n        meta: meta ?? get().queries[hashedKey]?.meta,\r\n        keyString: get().queries[hashedKey]?.keyString ?? keyToString(key),\r\n      });\r\n\r\n      syncTagsIndex(hashedKey, tags);\r\n      ensurePoller(hashedKey, refetchInterval);\r\n\r\n      const state = get();\r\n      const entry = state.queries[hashedKey];\r\n      const now = Date.now();\r\n      const isStale =\r\n        !entry?.fetchedAt ||\r\n        now - entry.fetchedAt > (entry?.staleTime ?? staleTime);\r\n\r\n      const current = entry?.data as\r\n        | InfiniteData<TPage, TParam>\r\n        | undefined;\r\n\r\n      if (direction === \"init\" && current && !isStale && !background) {\r\n        bump({ hits: 1 });\r\n        touch(hashedKey);\r\n        debugLog(\"hit\", hashedKey);\r\n        devtoolsEmit(\"hit\", { key: hashedKey });\r\n        return current;\r\n      }\r\n\r\n      if (state.inFlight[hashedKey]) {\r\n        bump({ dedupes: 1 });\r\n        debugLog(\"dedupe\", hashedKey);\r\n        devtoolsEmit(\"dedupe\", { key: hashedKey });\r\n        return state.inFlight[hashedKey] as Promise<\r\n          InfiniteData<TPage, TParam>\r\n        >;\r\n      }\r\n\r\n      if (\r\n        direction === \"init\" &&\r\n        current &&\r\n        isStale &&\r\n        (background || get().config.staleWhileRevalidate)\r\n      ) {\r\n        bump({ hits: 1, backgroundFetches: 1 });\r\n        debugLog(\"stale-hit+bg\", hashedKey);\r\n        devtoolsEmit(\"stale-hit+bg\", { key: hashedKey });\r\n        const originalKey = resolveKey(hashedKey);\r\n        get()\r\n          .refetchInfiniteQuery<TPage, TParam>(originalKey)\r\n          .catch(() => {});\r\n        touch(hashedKey);\r\n        return current;\r\n      }\r\n\r\n      if (abortOnNewFetch) {\r\n        get().abort(hashedKey);\r\n      }\r\n\r\n      bump({ misses: 1, fetches: 1 });\r\n      debugLog(\"miss(fetch)\", hashedKey);\r\n      devtoolsEmit(\"miss(fetch)\", { key: hashedKey });\r\n\r\n      const controller = isBrowser ? new AbortController() : undefined;\r\n      if (controller) aborters.set(hashedKey, controller);\r\n      inFlightMeta.set(hashedKey, { direction });\r\n\r\n      const promise = (async () => {\r\n        try {\r\n          const page = await runWithRetry<TPage>(\r\n            async () => {\r\n              if (controller?.signal?.aborted) {\r\n                throw (\r\n                  controller.signal.reason ??\r\n                  new DOMException(\"Aborted\", \"AbortError\")\r\n                );\r\n              }\r\n              return await fetcher({ pageParam, signal: controller?.signal });\r\n            },\r\n            retry ?? entry?.retry ?? get().config.retry,\r\n            (n) => bump({ retries: n }),\r\n            (attempt, attempts) => devtoolsEmit(\"retry\", { attempt, attempts })\r\n          );\r\n\r\n          let next: InfiniteData<TPage, TParam>;\r\n          if (!current) {\r\n            next = { pages: [page], pageParams: [pageParam] };\r\n          } else if (direction === \"backward\") {\r\n            next = {\r\n              pages: [page, ...current.pages],\r\n              pageParams: [pageParam, ...current.pageParams],\r\n            };\r\n          } else {\r\n            next = {\r\n              pages: [...current.pages, page],\r\n              pageParams: [...current.pageParams, pageParam],\r\n            };\r\n          }\r\n\r\n          setEntry(hashedKey, {\r\n            data: next,\r\n            error: undefined,\r\n            fetchedAt: Date.now(),\r\n            accessedAt: Date.now(),\r\n            staleTime,\r\n            cacheTime,\r\n            refetchInterval,\r\n            tags: tags ?? get().queries[hashedKey]?.tags ?? [],\r\n            retry: retry ?? get().queries[hashedKey]?.retry,\r\n            meta: meta ?? get().queries[hashedKey]?.meta,\r\n            keyString: get().queries[hashedKey]?.keyString ?? keyToString(key),\r\n          });\r\n\r\n          evictLRUIfNeeded();\r\n          scheduleFlush();\r\n          devtoolsEmit(\"fetch:success\", { key: hashedKey });\r\n          onSuccess?.(next);\r\n          onSettled?.(next, undefined);\r\n          return next;\r\n        } catch (error) {\r\n          if (isAbortError(error)) {\r\n            bump({ aborts: 1 });\r\n            setEntry(hashedKey, {\r\n              error,\r\n              fetchedAt: Date.now(),\r\n              lastAbortAt: Date.now(),\r\n              meta: meta ?? get().queries[hashedKey]?.meta,\r\n              keyString:\r\n                get().queries[hashedKey]?.keyString ?? keyToString(key),\r\n            });\r\n            scheduleFlush();\r\n            devtoolsEmit(\"fetch:abort\", { key: hashedKey });\r\n            throw error;\r\n          }\r\n\r\n          bump({ errors: 1 });\r\n          setEntry(hashedKey, {\r\n            error,\r\n            fetchedAt: Date.now(),\r\n            meta: meta ?? get().queries[hashedKey]?.meta,\r\n            keyString: get().queries[hashedKey]?.keyString ?? keyToString(key),\r\n          });\r\n          scheduleFlush();\r\n          devtoolsEmit(\"fetch:error\", { key: hashedKey });\r\n          onError?.(error);\r\n          onSettled?.(undefined, error);\r\n          throw error;\r\n        } finally {\r\n          set((s) => {\r\n            const next = { ...s.inFlight };\r\n            delete next[hashedKey];\r\n            return { inFlight: next };\r\n          });\r\n          inFlightMeta.delete(hashedKey);\r\n          if (controller && aborters.get(hashedKey) === controller) {\r\n            aborters.delete(hashedKey);\r\n          }\r\n        }\r\n      })();\r\n\r\n      set((s) => ({ inFlight: { ...s.inFlight, [hashedKey]: promise } }));\r\n      return promise;\r\n    },\r\n\r\n    async refetchInfiniteQuery<TPage, TParam>(key: QueryKey) {\r\n      const hashedKey = hashKey(key);\r\n      const entry = get().queries[hashedKey];\r\n      const fetcher = infiniteFetchers.get(hashedKey) as\r\n        | ((ctx: { pageParam: TParam; signal?: AbortSignal }) => Promise<TPage>)\r\n        | undefined;\r\n      const data = entry?.data as InfiniteData<TPage, TParam> | undefined;\r\n      if (!entry || !fetcher || !data) return undefined;\r\n      if (get().inFlight[hashedKey]) {\r\n        return get().inFlight[hashedKey] as Promise<\r\n          InfiniteData<TPage, TParam>\r\n        >;\r\n      }\r\n\r\n      const controller = isBrowser ? new AbortController() : undefined;\r\n      if (controller) aborters.set(hashedKey, controller);\r\n      inFlightMeta.set(hashedKey, { direction: \"init\" });\r\n\r\n      const promise = (async () => {\r\n        try {\r\n          const pages: TPage[] = [];\r\n          for (let i = 0; i < data.pageParams.length; i += 1) {\r\n            const pageParam = data.pageParams[i];\r\n            const page = await runWithRetry<TPage>(\r\n              async (_attemptIndex): Promise<TPage> => {\r\n                if (controller?.signal?.aborted) {\r\n                  throw (\r\n                    controller.signal.reason ??\r\n                    new DOMException(\"Aborted\", \"AbortError\")\r\n                  );\r\n                }\r\n                const result = await fetcher({\r\n                  pageParam,\r\n                  signal: controller?.signal,\r\n                });\r\n                return result as TPage;\r\n              },\r\n              entry.retry ?? get().config.retry,\r\n              (n) => bump({ retries: n }),\r\n              (attempt, attempts) => devtoolsEmit(\"retry\", { attempt, attempts })\r\n            );\r\n            pages.push(page);\r\n          }\r\n\r\n          const next: InfiniteData<TPage, TParam> = {\r\n            pages,\r\n            pageParams: data.pageParams,\r\n          };\r\n\r\n          setEntry(hashedKey, {\r\n            data: next,\r\n            error: undefined,\r\n            fetchedAt: Date.now(),\r\n            accessedAt: Date.now(),\r\n          });\r\n          scheduleFlush();\r\n          devtoolsEmit(\"fetch:success\", { key: hashedKey });\r\n          return next;\r\n        } catch (error) {\r\n          if (isAbortError(error)) {\r\n            bump({ aborts: 1 });\r\n            setEntry(hashedKey, {\r\n              error,\r\n              fetchedAt: Date.now(),\r\n              lastAbortAt: Date.now(),\r\n            });\r\n            scheduleFlush();\r\n            devtoolsEmit(\"fetch:abort\", { key: hashedKey });\r\n            throw error;\r\n          }\r\n\r\n          bump({ errors: 1 });\r\n          setEntry(hashedKey, { error, fetchedAt: Date.now() });\r\n          scheduleFlush();\r\n          devtoolsEmit(\"fetch:error\", { key: hashedKey });\r\n          throw error;\r\n        } finally {\r\n          set((s) => {\r\n            const next = { ...s.inFlight };\r\n            delete next[hashedKey];\r\n            return { inFlight: next };\r\n          });\r\n          inFlightMeta.delete(hashedKey);\r\n          if (controller && aborters.get(hashedKey) === controller) {\r\n            aborters.delete(hashedKey);\r\n          }\r\n        }\r\n      })();\r\n\r\n      set((s) => ({ inFlight: { ...s.inFlight, [hashedKey]: promise } }));\r\n      return promise;\r\n    },\r\n\r\n    async prefetchQuery<T>(key: QueryKey, options: FetchQueryOptions<T>) {\r\n      const hashedKey = hashKey(key);\r\n      bump({ prefetched: 1 });\r\n      devtoolsEmit(\"prefetch\", { key: hashedKey });\r\n      await get().fetchQuery<T>(key, { ...options, background: false });\r\n    },\r\n\r\n    invalidate(key) {\r\n      const hashedKey = hashKey(key);\r\n      bump({ invalidations: 1 });\r\n\r\n      get().abort(hashedKey);\r\n      withDraft(\r\n        (draft) => {\r\n          if (!draft[hashedKey]) return;\r\n          draft[hashedKey] = {\r\n            ...draft[hashedKey],\r\n            fetchedAt: 0,\r\n            error: undefined,\r\n          };\r\n        },\r\n        false\r\n      );\r\n      scheduleFlush();\r\n      debugLog(\"invalidate\", hashedKey);\r\n      devtoolsEmit(\"invalidate\", { key: hashedKey });\r\n      broadcast({ type: \"invalidate\", payload: { key: hashedKey } });\r\n    },\r\n\r\n    invalidateByPrefix(prefix) {\r\n      bump({ invalidations: 1 });\r\n\r\n      const keys = Object.keys(get().queries).filter((k) => {\r\n        const original = keyMap.get(k) ?? k;\r\n        const keyString =\r\n          get().queries[k]?.keyString ?? keyToString(original as QueryKey);\r\n        return keyString.startsWith(prefix);\r\n      });\r\n      keys.forEach((k) => get().abort(k));\r\n      withDraft(\r\n        (draft) => {\r\n          Object.keys(draft).forEach((k) => {\r\n            const original = keyMap.get(k) ?? k;\r\n            const keyString =\r\n              draft[k]?.keyString ?? keyToString(original as QueryKey);\r\n            if (!keyString.startsWith(prefix)) return;\r\n            draft[k] = {\r\n              ...draft[k],\r\n              fetchedAt: 0,\r\n              error: undefined,\r\n            };\r\n          });\r\n        },\r\n        false\r\n      );\r\n      scheduleFlush();\r\n      debugLog(\"invalidateByPrefix\", prefix);\r\n      devtoolsEmit(\"invalidateByPrefix\", { prefix });\r\n      broadcast({ type: \"invalidateByPrefix\", payload: { prefix } });\r\n    },\r\n\r\n    invalidateTags(tags) {\r\n      bump({ invalidations: 1 });\r\n      const list = Array.isArray(tags) ? tags : [tags];\r\n\r\n      const keysToInvalidate = new Set<QueryKeyHash>();\r\n      list.forEach((t) => {\r\n        const setKeys = tagIndex.get(t);\r\n        if (!setKeys) return;\r\n        setKeys.forEach((k) => keysToInvalidate.add(k));\r\n      });\r\n\r\n      get().batch(() => {\r\n        keysToInvalidate.forEach((k) => get().invalidate(k));\r\n      });\r\n\r\n      debugLog(\"invalidateTags\", list);\r\n      devtoolsEmit(\"invalidateTags\", {\r\n        tags: list,\r\n        keys: Array.from(keysToInvalidate),\r\n      });\r\n      broadcast({ type: \"invalidateTags\", payload: { tags: list } });\r\n    },\r\n\r\n    cancelByTags(tags) {\r\n      const list = Array.isArray(tags) ? tags : [tags];\r\n      const keysToCancel = new Set<QueryKeyHash>();\r\n      list.forEach((t) => {\r\n        const setKeys = tagIndex.get(t);\r\n        if (!setKeys) return;\r\n        setKeys.forEach((k) => keysToCancel.add(k));\r\n      });\r\n      keysToCancel.forEach((k) => get().abort(k));\r\n      devtoolsEmit(\"cancelTags\", {\r\n        tags: list,\r\n        keys: Array.from(keysToCancel),\r\n      });\r\n    },\r\n\r\n    abort(key) {\r\n      const hashedKey = hashKey(key);\r\n      const controller = aborters.get(hashedKey);\r\n      if (!controller) return;\r\n      try {\r\n        controller.abort();\r\n      } catch {}\r\n      aborters.delete(hashedKey);\r\n      devtoolsEmit(\"abort\", { key: hashedKey });\r\n    },\r\n\r\n    cancelMutation(key) {\r\n      const hashedKey = hashKey(key);\r\n      const controller = mutationAborters.get(hashedKey);\r\n      if (!controller) return;\r\n      try {\r\n        controller.abort();\r\n      } catch {}\r\n      mutationAborters.delete(hashedKey);\r\n      devtoolsEmit(\"mutation:abort\", { key: hashedKey });\r\n    },\r\n\r\n    batch(fn) {\r\n      batchDepth += 1;\r\n      try {\r\n        fn();\r\n      } finally {\r\n        batchDepth -= 1;\r\n        if (batchDepth === 0 && pendingQueries) {\r\n          const next = pendingQueries;\r\n          pendingQueries = null;\r\n          set({ queries: next });\r\n          if (flushRequested) {\r\n            flushRequested = false;\r\n            scheduleFlush();\r\n          }\r\n          devtoolsEmit(\"batch:flush\", {});\r\n        }\r\n      }\r\n    },\r\n\r\n    gc() {\r\n      const now = Date.now();\r\n      let evicted = 0;\r\n\r\n      withDraft((draft) => {\r\n        Object.entries(draft).forEach(([k, q]) => {\r\n          if (!q.fetchedAt) return;\r\n          if (now - q.fetchedAt > q.cacheTime) {\r\n            get().abort(k);\r\n            ensurePoller(k, undefined);\r\n\r\n            removeKeyFromAllTags(k);\r\n\r\n            delete draft[k];\r\n            evicted += 1;\r\n          }\r\n        });\r\n      });\r\n\r\n      if (evicted > 0) {\r\n        bump({ gcEvictions: evicted });\r\n        scheduleFlush();\r\n        debugLog(\"gc evicted\", evicted);\r\n        devtoolsEmit(\"gc\", { evicted });\r\n      }\r\n    },\r\n\r\n    async mutate<TVars, TResult>(opts: MutateOptions<TVars, TResult>) {\r\n      bump({ mutations: 1 });\r\n      devtoolsEmit(\"mutate:start\", {});\r\n\r\n      const defaults = getMutationDefaultOptions(opts.mutationKey, get().config);\r\n      const mergedOptions: MutateOptions<TVars, TResult> = {\r\n        ...defaults,\r\n        ...opts,\r\n        retry: opts.retry ?? defaults.retry,\r\n        abortOnNewMutation:\r\n          opts.abortOnNewMutation ?? defaults.abortOnNewMutation,\r\n        invalidateKeys: opts.invalidateKeys ?? defaults.invalidateKeys,\r\n        invalidatePrefixes:\r\n          opts.invalidatePrefixes ?? defaults.invalidatePrefixes,\r\n        invalidateTags: opts.invalidateTags ?? defaults.invalidateTags,\r\n        optimistic: opts.optimistic ?? defaults.optimistic,\r\n        updateCache: opts.updateCache ?? defaults.updateCache,\r\n      } as MutateOptions<TVars, TResult>;\r\n\r\n      const {\r\n        mutationFn,\r\n        variables,\r\n        optimistic,\r\n        updateCache,\r\n        invalidateKeys,\r\n        invalidatePrefixes,\r\n        invalidateTags,\r\n        onSuccess,\r\n        onError,\r\n        retry,\r\n        abortOnNewMutation = true,\r\n      } = mergedOptions;\r\n\r\n      const mutationKey = mergedOptions.mutationKey ?? \"__mutation__\";\r\n      const hashedKey = hashKey(mutationKey);\r\n\r\n      if (abortOnNewMutation) {\r\n        get().cancelMutation(hashedKey);\r\n      }\r\n\r\n      const controller = isBrowser ? new AbortController() : undefined;\r\n      if (controller) mutationAborters.set(hashedKey, controller);\r\n\r\n      set((s) => ({\r\n        mutations: {\r\n          ...s.mutations,\r\n          [hashedKey]: {\r\n            status: \"loading\",\r\n            data: s.mutations[hashedKey]?.data,\r\n            error: undefined,\r\n            variables,\r\n            updatedAt: Date.now(),\r\n          },\r\n        },\r\n      }));\r\n\r\n      const snapshots = new Map<QueryKeyHash, unknown>();\r\n\r\n      if (optimistic && optimistic.length > 0) {\r\n        bump({ optimisticApplied: 1 });\r\n\r\n        get().batch(() => {\r\n          optimistic.forEach(({ key, update }) => {\r\n            const k = hashKey(key);\r\n            const prev = get().queries[k]?.data;\r\n            snapshots.set(k, prev);\r\n\r\n            setEntry(k, {\r\n              data: update(prev),\r\n              accessedAt: Date.now(),\r\n            });\r\n          });\r\n        });\r\n\r\n        scheduleFlush();\r\n        debugLog(\r\n          \"optimistic applied\",\r\n          optimistic.map((o) => o.key)\r\n        );\r\n        devtoolsEmit(\"mutate:optimistic\", {\r\n          keys: optimistic.map((o) => o.key),\r\n        });\r\n      }\r\n\r\n      const promise = (async () => {\r\n        try {\r\n          const result = await runWithRetry<TResult>(\r\n            async () => mutationFn(variables, { signal: controller?.signal }),\r\n            retry ?? get().config.retry,\r\n            (n) => bump({ retries: n }),\r\n            (attempt, attempts) => devtoolsEmit(\"retry\", { attempt, attempts })\r\n          );\r\n\r\n          if (updateCache && updateCache.length > 0) {\r\n            get().batch(() => {\r\n              updateCache.forEach(({ key, update }) => {\r\n                const k = hashKey(key);\r\n                const prev = get().queries[k]?.data;\r\n                setEntry(k, {\r\n                  data: update(prev, result),\r\n                  fetchedAt: Date.now(),\r\n                  accessedAt: Date.now(),\r\n                });\r\n              });\r\n            });\r\n          }\r\n\r\n          if (\r\n            (invalidateKeys && invalidateKeys.length) ||\r\n            (invalidatePrefixes && invalidatePrefixes.length) ||\r\n            (invalidateTags && invalidateTags.length)\r\n          ) {\r\n            get().batch(() => {\r\n              invalidateKeys?.forEach((k) => get().invalidate(k));\r\n              invalidatePrefixes?.forEach((p) => get().invalidateByPrefix(p));\r\n              if (invalidateTags?.length) get().invalidateTags(invalidateTags);\r\n            });\r\n          }\r\n\r\n          scheduleFlush();\r\n          onSuccess?.(result, variables);\r\n          devtoolsEmit(\"mutate:success\", {});\r\n          set((s) => ({\r\n            mutations: {\r\n              ...s.mutations,\r\n              [hashedKey]: {\r\n                status: \"success\",\r\n                data: result,\r\n                error: undefined,\r\n                variables,\r\n                updatedAt: Date.now(),\r\n              },\r\n            },\r\n          }));\r\n          return result;\r\n        } catch (error) {\r\n          if (optimistic && optimistic.length > 0) {\r\n            bump({ optimisticRolledBack: 1 });\r\n\r\n            get().batch(() => {\r\n              optimistic.forEach(({ key }) => {\r\n                const k = hashKey(key);\r\n                const prev = snapshots.get(k);\r\n                setEntry(k, { data: prev, accessedAt: Date.now() });\r\n              });\r\n            });\r\n\r\n            scheduleFlush();\r\n            debugLog(\"optimistic rollback\");\r\n            devtoolsEmit(\"mutate:rollback\", {\r\n              keys: optimistic.map((o) => o.key),\r\n            });\r\n          }\r\n\r\n          onError?.(error, variables);\r\n          devtoolsEmit(\"mutate:error\", {});\r\n          set((s) => ({\r\n            mutations: {\r\n              ...s.mutations,\r\n              [hashedKey]: {\r\n                status: \"error\",\r\n                data: s.mutations[hashedKey]?.data,\r\n                error,\r\n                variables,\r\n                updatedAt: Date.now(),\r\n              },\r\n            },\r\n          }));\r\n          throw error;\r\n        } finally {\r\n          if (controller && mutationAborters.get(hashedKey) === controller) {\r\n            mutationAborters.delete(hashedKey);\r\n          }\r\n        }\r\n      })();\r\n\r\n      set((s) => ({\r\n        mutations: {\r\n          ...s.mutations,\r\n          [hashedKey]: {\r\n            status: \"loading\",\r\n            data: s.mutations[hashedKey]?.data,\r\n            error: undefined,\r\n            variables,\r\n            promise,\r\n            updatedAt: Date.now(),\r\n          },\r\n        },\r\n      }));\r\n\r\n      return promise;\r\n    },\r\n\r\n    setDebug(debug) {\r\n      set((s) => ({ config: { ...s.config, debug } }));\r\n      devtoolsEmit(\"config:debug\", { debug });\r\n    },\r\n\r\n    setConfig(partial) {\r\n      set((s) => ({\r\n        config: {\r\n          ...s.config,\r\n          ...partial,\r\n          persistence: {\r\n            ...s.config.persistence,\r\n            ...(partial.persistence ?? {}),\r\n          },\r\n          retry: {\r\n            ...s.config.retry,\r\n            ...(partial.retry ?? {}),\r\n          },\r\n          multiTabSync: {\r\n            ...s.config.multiTabSync,\r\n            ...(partial.multiTabSync ?? {}),\r\n          },\r\n          devtools: {\r\n            ...s.config.devtools,\r\n            ...(partial.devtools ?? {}),\r\n          },\r\n        },\r\n      }));\r\n      devtoolsEmit(\"config:set\", { partial });\r\n    },\r\n\r\n    getMutation(key) {\r\n      const hashedKey = hashKey(key);\r\n      return get().mutations[hashedKey];\r\n    },\r\n\r\n    setQueryData(key, data, options) {\r\n      const hashedKey = hashKey(key);\r\n      keyMap.set(hashedKey, key);\r\n      setEntry(hashedKey, {\r\n        data,\r\n        error: undefined,\r\n        fetchedAt: options?.fetchedAt ?? Date.now(),\r\n        accessedAt: Date.now(),\r\n        staleTime:\r\n          options?.staleTime ??\r\n          get().queries[hashedKey]?.staleTime ??\r\n          DEFAULT_STALE_TIME,\r\n        cacheTime:\r\n          options?.cacheTime ??\r\n          get().queries[hashedKey]?.cacheTime ??\r\n          DEFAULT_CACHE_TIME,\r\n        refetchInterval:\r\n          options?.refetchInterval ?? get().queries[hashedKey]?.refetchInterval,\r\n        tags: options?.tags ?? get().queries[hashedKey]?.tags ?? [],\r\n        retry: options?.retry ?? get().queries[hashedKey]?.retry,\r\n        meta: options?.meta ?? get().queries[hashedKey]?.meta,\r\n        keyString: get().queries[hashedKey]?.keyString ?? keyToString(key),\r\n      });\r\n      syncTagsIndex(hashedKey, options?.tags);\r\n      evictLRUIfNeeded();\r\n      scheduleFlush();\r\n      devtoolsEmit(\"setQueryData\", { key: hashedKey });\r\n    },\r\n\r\n    addObserver(key) {\r\n      const hashedKey = hashKey(key);\r\n      const next = (observers.get(hashedKey) ?? 0) + 1;\r\n      observers.set(hashedKey, next);\r\n      devtoolsEmit(\"observer:add\", { key: hashedKey, count: next });\r\n    },\r\n\r\n    removeObserver(key) {\r\n      const hashedKey = hashKey(key);\r\n      const prev = observers.get(hashedKey) ?? 0;\r\n      const next = Math.max(0, prev - 1);\r\n      if (next === 0) observers.delete(hashedKey);\r\n      else observers.set(hashedKey, next);\r\n      devtoolsEmit(\"observer:remove\", { key: hashedKey, count: next });\r\n    },\r\n\r\n    getObserversCount(key) {\r\n      const hashedKey = hashKey(key);\r\n      return observers.get(hashedKey) ?? 0;\r\n    },\r\n\r\n    getInFlightDirection(key) {\r\n      const hashedKey = hashKey(key);\r\n      return inFlightMeta.get(hashedKey)?.direction;\r\n    },\r\n\r\n    clear() {\r\n      Object.keys(get().queries).forEach((k) => get().abort(k));\r\n\r\n      if (isBrowser) {\r\n        pollers.forEach((p) => window.clearInterval(p.timer));\r\n      }\r\n      pollers.clear();\r\n      fetchers.clear();\r\n      infiniteFetchers.clear();\r\n      selectMemo.clear();\r\n      tagIndex.clear();\r\n      aborters.clear();\r\n      mutationAborters.clear();\r\n      keyMap.clear();\r\n      observers.clear();\r\n      inFlightMeta.clear();\r\n\r\n      set({ queries: {}, inFlight: {}, mutations: {} });\r\n      scheduleFlush();\r\n      debugLog(\"clear\");\r\n      devtoolsEmit(\"clear\", {});\r\n      broadcast({ type: \"clear\", payload: {} });\r\n    },\r\n\r\n    getSnapshot() {\r\n      const s = get();\r\n      return {\r\n        config: s.config,\r\n        metrics: s.metrics,\r\n        queryKeys: Object.keys(s.queries),\r\n        inFlightKeys: Object.keys(s.inFlight).filter((k) => !!s.inFlight[k]),\r\n        mutationKeys: Object.keys(s.mutations),\r\n      };\r\n    },\r\n  }));\r\n\r\n  const debugLog = (...args: unknown[]) => {\r\n    const { config } = store.getState();\r\n    if (!config.debug) return;\r\n    console.debug(\"[QueryStore]\", ...args);\r\n  };\r\n\r\n  const bump = (partial: Partial<Metrics>) => {\r\n    store.setState((s) => ({\r\n      metrics: {\r\n        ...s.metrics,\r\n        ...Object.fromEntries(\r\n          Object.entries(partial).map(([k, v]) => [\r\n            k,\r\n            (s.metrics as any)[k] + (v as number),\r\n          ])\r\n        ),\r\n      },\r\n    }));\r\n  };\r\n\r\n  const serializeQueries = (queries: Record<QueryKeyHash, QueryEntry>) => {\r\n    const out: Record<QueryKeyHash, Omit<QueryEntry, \"fetcher\">> = {};\r\n    Object.entries(queries).forEach(([k, q]) => {\r\n      const { fetcher: _f, error: _e, meta: _m, ...rest } = q;\r\n      out[k] = rest;\r\n    });\r\n    return out;\r\n  };\r\n\r\n  const devtoolsEmit = (type: string, payload: unknown) => {\r\n    const { devtools } = store.getState().config;\r\n    if (!isBrowser) return;\r\n    if (!devtools.enabled) return;\r\n\r\n    if (devtools.emitEvents) {\r\n      try {\r\n        window.dispatchEvent(\r\n          new CustomEvent(devtools.eventName, {\r\n            detail: { type, payload, ts: Date.now() },\r\n          })\r\n        );\r\n      } catch {}\r\n    }\r\n\r\n    if (store.getState().config.debug) {\r\n      debugLog(\"event\", type, payload);\r\n    }\r\n  };\r\n\r\n  const scheduleFlush = () => {\r\n    if (!isBrowser) return;\r\n    const { persistence } = store.getState().config;\r\n    if (persistence.mode === \"none\") return;\r\n\r\n    if (flushTimer) window.clearTimeout(flushTimer);\r\n    flushTimer = window.setTimeout(async () => {\r\n      flushTimer = null;\r\n      const { config, queries } = store.getState();\r\n      const payload = serializeQueries(queries);\r\n\r\n      try {\r\n        if (config.persistence.mode === \"session\") {\r\n          sessionStorage.setItem(\r\n            config.persistence.storageKey,\r\n            JSON.stringify(payload)\r\n          );\r\n          debugLog(\"persist(session) ok\");\r\n        } else if (config.persistence.mode === \"indexeddb\") {\r\n          await idbSet(\r\n            config.persistence.dbName,\r\n            config.persistence.storeName,\r\n            config.persistence.storageKey,\r\n            payload\r\n          );\r\n          debugLog(\"persist(indexeddb) ok\");\r\n        }\r\n      } catch (e) {\r\n        debugLog(\"persist failed\", e);\r\n      }\r\n    }, store.getState().config.persistence.flushDebounceMs);\r\n  };\r\n\r\n  const restorePersisted = async () => {\r\n    if (!isBrowser) return;\r\n    const { persistence } = store.getState().config;\r\n    if (persistence.mode === \"none\") return;\r\n\r\n    try {\r\n      if (persistence.mode === \"session\") {\r\n        const raw = sessionStorage.getItem(persistence.storageKey);\r\n        if (!raw) return;\r\n        const parsed = JSON.parse(raw) as Record<\r\n          QueryKeyHash,\r\n          Omit<QueryEntry, \"fetcher\">\r\n        >;\r\n        store.getState().hydrate(parsed);\r\n        debugLog(\"restore(session) ok\");\r\n      } else if (persistence.mode === \"indexeddb\") {\r\n        const parsed = await idbGet<\r\n          Record<QueryKeyHash, Omit<QueryEntry, \"fetcher\">>\r\n        >(persistence.dbName, persistence.storeName, persistence.storageKey);\r\n        if (!parsed) return;\r\n        store.getState().hydrate(parsed);\r\n        debugLog(\"restore(indexeddb) ok\");\r\n      }\r\n    } catch (e) {\r\n      debugLog(\"restore failed\", e);\r\n    }\r\n  };\r\n\r\n  const withDraft = (\r\n    fn: (draft: Record<QueryKeyHash, QueryEntry>) => void,\r\n    flush = true\r\n  ) => {\r\n    if (batchDepth > 0) {\r\n      if (!pendingQueries) pendingQueries = { ...store.getState().queries };\r\n      fn(pendingQueries);\r\n      if (flush) flushRequested = true;\r\n      return;\r\n    }\r\n    store.setState((s) => {\r\n      const next = { ...s.queries };\r\n      fn(next);\r\n      return { queries: next };\r\n    });\r\n    if (flush) scheduleFlush();\r\n  };\r\n\r\n  const setEntry = (key: QueryKeyHash, patch: Partial<QueryEntry>) => {\r\n    withDraft((draft) => {\r\n      const prev = draft[key];\r\n      const hasData = Object.prototype.hasOwnProperty.call(patch, \"data\");\r\n      const nextData = hasData\r\n        ? applyStructuralSharing(prev?.data, patch.data as any)\r\n        : prev?.data;\r\n      draft[key] = {\r\n        data: nextData,\r\n        error: prev?.error,\r\n        meta: prev?.meta,\r\n        keyString: prev?.keyString,\r\n        fetchedAt: prev?.fetchedAt,\r\n        accessedAt: prev?.accessedAt,\r\n        staleTime: prev?.staleTime ?? DEFAULT_STALE_TIME,\r\n        cacheTime: prev?.cacheTime ?? DEFAULT_CACHE_TIME,\r\n        refetchInterval: prev?.refetchInterval,\r\n        fetcher: prev?.fetcher,\r\n        tags: prev?.tags ?? [],\r\n        retry: prev?.retry,\r\n        lastAbortAt: prev?.lastAbortAt,\r\n        ...patch,\r\n      };\r\n    });\r\n  };\r\n\r\n  const touch = (key: QueryKeyHash) => {\r\n    setEntry(key, { accessedAt: Date.now() });\r\n  };\r\n\r\n  const evictLRUIfNeeded = () => {\r\n    const { maxEntries } = store.getState().config;\r\n    const queries = store.getState().queries;\r\n    const keys = Object.keys(queries);\r\n    if (keys.length <= maxEntries) return;\r\n\r\n    const sorted = keys\r\n      .map((k) => {\r\n        const q = queries[k];\r\n        const t = q.accessedAt ?? q.fetchedAt ?? 0;\r\n        return { k, t };\r\n      })\r\n      .sort((a, b) => a.t - b.t);\r\n\r\n    const toRemove = sorted.slice(0, Math.max(0, keys.length - maxEntries));\r\n    if (toRemove.length === 0) return;\r\n\r\n    store.getState().batch(() => {\r\n      toRemove.forEach(({ k }) => {\r\n        store.getState().invalidate(k);\r\n      });\r\n    });\r\n\r\n    bump({ lruEvictions: toRemove.length });\r\n    debugLog(\r\n      \"LRU evicted\",\r\n      toRemove.map((x) => x.k)\r\n    );\r\n    devtoolsEmit(\"lru\", { keys: toRemove.map((x) => x.k) });\r\n  };\r\n\r\n  const ensurePoller = (key: QueryKeyHash, interval?: number) => {\r\n    if (!isBrowser) return;\r\n\r\n    if (!interval || interval <= 0) {\r\n      const existing = pollers.get(key);\r\n      if (existing) window.clearInterval(existing.timer);\r\n      pollers.delete(key);\r\n      return;\r\n    }\r\n\r\n    const existing = pollers.get(key);\r\n    if (existing && existing.interval === interval) return;\r\n    if (existing) window.clearInterval(existing.timer);\r\n\r\n    const timer = window.setInterval(() => {\r\n      const fetcher = fetchers.get(key);\r\n      const entry = store.getState().queries[key];\r\n      if (!fetcher || !entry) return;\r\n      const originalKey = resolveKey(key);\r\n\r\n      if (infiniteFetchers.has(key)) {\r\n        store\r\n          .getState()\r\n          .refetchInfiniteQuery(originalKey)\r\n          .catch(() => {});\r\n        return;\r\n      }\r\n\r\n      store\r\n        .getState()\r\n        .fetchQuery(originalKey, {\r\n          fetcher: fetcher as any,\r\n          staleTime: entry.staleTime,\r\n          cacheTime: entry.cacheTime,\r\n          background: true,\r\n          skipStaleWhileRevalidate: true,\r\n          refetchInterval: interval,\r\n          tags: entry.tags,\r\n          retry: entry.retry,\r\n        })\r\n        .catch(() => {});\r\n    }, interval);\r\n\r\n    pollers.set(key, { timer, interval });\r\n  };\r\n\r\n  const syncTagsIndex = (key: QueryKeyHash, nextTags?: string[]) => {\r\n    if (!nextTags) return;\r\n\r\n    removeKeyFromAllTags(key);\r\n\r\n    nextTags.forEach((t) => {\r\n      if (!tagIndex.has(t)) tagIndex.set(t, new Set());\r\n      tagIndex.get(t)!.add(key);\r\n    });\r\n  };\r\n\r\n  const removeKeyFromAllTags = (key: QueryKeyHash) => {\r\n    tagIndex.forEach((setKeys) => {\r\n      setKeys.delete(key);\r\n    });\r\n\r\n    Array.from(tagIndex.entries()).forEach(([t, setKeys]) => {\r\n      if (setKeys.size === 0) tagIndex.delete(t);\r\n    });\r\n  };\r\n\r\n  const refetchStaleQueries = () => {\r\n    if (typeof navigator !== \"undefined\" && navigator.onLine === false) return;\r\n    const { queries, fetchQuery } = store.getState();\r\n    Object.entries(queries).forEach(([key, q]) => {\r\n      const observersCount = observers.get(key) ?? 0;\r\n      if (observersCount === 0) return;\r\n      if (!q.data) return;\r\n      const isStale = !q.fetchedAt || Date.now() - q.fetchedAt > q.staleTime;\r\n      if (!isStale) return;\r\n\r\n      bump({ backgroundFetches: 1 });\r\n      const originalKey = resolveKey(key);\r\n      if (infiniteFetchers.has(key)) {\r\n        store.getState().refetchInfiniteQuery(originalKey).catch(() => {});\r\n        return;\r\n      }\r\n\r\n      const f = fetchers.get(key);\r\n      if (!f) return;\r\n      fetchQuery(originalKey, {\r\n        fetcher: f as any,\r\n        staleTime: q.staleTime,\r\n        cacheTime: q.cacheTime,\r\n        background: true,\r\n        skipStaleWhileRevalidate: true,\r\n        refetchInterval: q.refetchInterval,\r\n        tags: q.tags,\r\n        retry: q.retry,\r\n      }).catch(() => {});\r\n    });\r\n  };\r\n\r\n  if (isBrowser) {\r\n    restorePersisted().catch(() => {});\r\n\r\n    if (cfg.refetchOnFocus) {\r\n      window.addEventListener(\"focus\", () => {\r\n        refetchStaleQueries();\r\n      });\r\n    }\r\n\r\n    if (cfg.refetchOnOnline) {\r\n      window.addEventListener(\"online\", () => {\r\n        refetchStaleQueries();\r\n      });\r\n    }\r\n\r\n    if (cfg.refetchOnReconnect) {\r\n      window.addEventListener(\"focus\", () => {\r\n        refetchStaleQueries();\r\n      });\r\n    }\r\n\r\n    if (cfg.devtools.enabled && cfg.devtools.exposeToWindow) {\r\n      (window as any).__QUERY_STORE__ = store;\r\n      (window as any).__QUERY_STORE_GET_SNAPSHOT__ = () =>\r\n        store.getState().getSnapshot();\r\n      devtoolsEmit(\"devtools:exposed\", {});\r\n    }\r\n\r\n    if (cfg.devtools.overlay?.enabled) {\r\n      const position = cfg.devtools.overlay.position ?? \"bottom-right\";\r\n      const styleBase =\r\n        \"position:fixed;z-index:2147483647;padding:8px 10px;background:#0f1115;color:#f8f8f2;border-radius:8px;font:12px/1.4 monospace;opacity:0.9;\";\r\n      const positionStyle =\r\n        position === \"bottom-left\"\r\n          ? \"bottom:12px;left:12px;\"\r\n          : position === \"top-right\"\r\n            ? \"top:12px;right:12px;\"\r\n            : position === \"top-left\"\r\n              ? \"top:12px;left:12px;\"\r\n              : \"bottom:12px;right:12px;\";\r\n      const root = document.createElement(\"div\");\r\n      root.setAttribute(\"style\", `${styleBase}${positionStyle}`);\r\n      const render = () => {\r\n        const { metrics, queries, inFlight, mutations } = store.getState();\r\n        root.textContent =\r\n          `queries:${Object.keys(queries).length} ` +\r\n          `inFlight:${Object.keys(inFlight).filter((k) => !!inFlight[k]).length} ` +\r\n          `mutations:${Object.keys(mutations).length} ` +\r\n          `hits:${metrics.hits} ` +\r\n          `misses:${metrics.misses} ` +\r\n          `errors:${metrics.errors}`;\r\n      };\r\n      render();\r\n      document.body.appendChild(root);\r\n      store.subscribe(render);\r\n    }\r\n\r\n    if (cfg.multiTabSync.enabled && channel) {\r\n      channel.onmessage = (event) => {\r\n        const message = event.data as {\r\n          type: string;\r\n          payload?: any;\r\n          sourceId?: string;\r\n        };\r\n        if (message.sourceId === instanceId) return;\r\n        suppressBroadcast = true;\r\n        try {\r\n          if (message.type === \"invalidate\") {\r\n            store.getState().invalidate(message.payload.key);\r\n          }\r\n          if (message.type === \"invalidateByPrefix\") {\r\n            store.getState().invalidateByPrefix(message.payload.prefix);\r\n          }\r\n          if (message.type === \"invalidateTags\") {\r\n            store.getState().invalidateTags(message.payload.tags);\r\n          }\r\n          if (message.type === \"clear\") {\r\n            store.getState().clear();\r\n          }\r\n        } finally {\r\n          suppressBroadcast = false;\r\n        }\r\n      };\r\n    }\r\n  }\r\n\r\n  if (cfg.gcIntervalMs && isBrowser) {\r\n    window.setInterval(() => {\r\n      store.getState().gc();\r\n    }, cfg.gcIntervalMs);\r\n  }\r\n\r\n  return store;\r\n}\r\n\r\nexport const useQueryStore = createQueryClient();\r\n","import { Metrics, QueryClientConfig } from \"../types\";\r\n\r\nexport const DEFAULT_STALE_TIME = 30_000;\r\nexport const DEFAULT_CACHE_TIME = 5 * 60_000;\r\n\r\nexport const createMetrics = (): Metrics => ({\r\n  hits: 0,\r\n  misses: 0,\r\n  fetches: 0,\r\n  backgroundFetches: 0,\r\n  dedupes: 0,\r\n  errors: 0,\r\n  invalidations: 0,\r\n  gcEvictions: 0,\r\n  lruEvictions: 0,\r\n  prefetched: 0,\r\n  mutations: 0,\r\n  optimisticApplied: 0,\r\n  optimisticRolledBack: 0,\r\n  aborts: 0,\r\n  retries: 0,\r\n});\r\n\r\nexport const defaultConfig: QueryClientConfig = {\r\n  maxEntries: 200,\r\n  persistence: {\r\n    mode: \"indexeddb\",\r\n    storageKey: \"__query_cache__\",\r\n    dbName: \"__query_cache_db__\",\r\n    storeName: \"cache\",\r\n    flushDebounceMs: 250,\r\n  },\r\n  debug: false,\r\n  refetchOnFocus: true,\r\n  refetchOnReconnect: false,\r\n  refetchOnOnline: false,\r\n  retry: {\r\n    attempts: 1,\r\n    delay: 300,\r\n    retryOn: () => true,\r\n  },\r\n  staleWhileRevalidate: false,\r\n  selectMemoMaxEntries: 500,\r\n  structuralSharing: true,\r\n  gcIntervalMs: 60_000,\r\n  suspense: false,\r\n  throwOnError: false,\r\n  queryDefaults: [],\r\n  mutationDefaults: [],\r\n  multiTabSync: {\r\n    enabled: false,\r\n    channelName: \"__query_store_sync__\",\r\n  },\r\n  devtools: {\r\n    enabled: true,\r\n    exposeToWindow: true,\r\n    emitEvents: false,\r\n    eventName: \"__query_store__\",\r\n    overlay: {\r\n      enabled: false,\r\n      position: \"bottom-right\",\r\n    },\r\n  },\r\n};\r\n","import { QueryKey, QueryKeyHash } from \"../types\";\r\n\r\nexport const stableStringify = (value: unknown): string => {\r\n  const stack = new Set<unknown>();\r\n  const walk = (val: unknown): string => {\r\n    if (val === null) return \"null\";\r\n    const type = typeof val;\r\n    if (type === \"string\") return JSON.stringify(val);\r\n    if (type === \"number\") return Number.isFinite(val) ? String(val) : \"null\";\r\n    if (type === \"boolean\") return val ? \"true\" : \"false\";\r\n    if (type === \"undefined\") return \"\\\"__undefined__\\\"\";\r\n    if (type === \"bigint\") return JSON.stringify(`__bigint__:${val}`);\r\n    if (type === \"function\") return \"\\\"__function__\\\"\";\r\n    if (val instanceof Date) return JSON.stringify(`__date__:${val.toISOString()}`);\r\n    if (Array.isArray(val)) {\r\n      return `[${val.map((item) => walk(item)).join(\",\")}]`;\r\n    }\r\n    if (type === \"object\") {\r\n      if (stack.has(val)) throw new Error(\"Circular value in query key\");\r\n      stack.add(val);\r\n      const obj = val as Record<string, unknown>;\r\n      const keys = Object.keys(obj).sort();\r\n      const result = `{${keys\r\n        .map((k) => `${JSON.stringify(k)}:${walk(obj[k])}`)\r\n        .join(\",\")}}`;\r\n      stack.delete(val);\r\n      return result;\r\n    }\r\n    return \"\\\"__unknown__\\\"\";\r\n  };\r\n  return walk(value);\r\n};\r\n\r\nexport const hashKey = (key: QueryKey): QueryKeyHash => {\r\n  if (typeof key === \"string\") return key;\r\n  return `k:${stableStringify(key)}`;\r\n};\r\n\r\nexport const keyToString = (key: QueryKey): string => {\r\n  if (typeof key === \"string\") return key;\r\n  const first = key[0];\r\n  if (typeof first === \"string\") return first;\r\n  return hashKey(key);\r\n};\r\n","export const isPlainObject = (value: unknown): value is Record<string, unknown> => {\r\n  if (!value || typeof value !== \"object\") return false;\r\n  const proto = Object.getPrototypeOf(value);\r\n  return proto === Object.prototype || proto === null;\r\n};\r\n\r\nexport const replaceEqualDeep = <T>(a: T, b: T): T => {\r\n  if (a === b) return a;\r\n  if (Array.isArray(a) && Array.isArray(b)) {\r\n    const length = b.length;\r\n    const result = new Array(length);\r\n    let equal = a.length === length;\r\n    for (let i = 0; i < length; i += 1) {\r\n      result[i] = replaceEqualDeep(a[i], b[i]);\r\n      if (result[i] !== a[i]) equal = false;\r\n    }\r\n    return (equal ? a : (result as unknown as T));\r\n  }\r\n  if (isPlainObject(a) && isPlainObject(b)) {\r\n    const aKeys = Object.keys(a);\r\n    const bKeys = Object.keys(b);\r\n    if (aKeys.length !== bKeys.length) {\r\n      const out: Record<string, unknown> = {};\r\n      bKeys.forEach((k) => {\r\n        out[k] = replaceEqualDeep((a as any)[k], (b as any)[k]);\r\n      });\r\n      return out as T;\r\n    }\r\n    let equal = true;\r\n    const out: Record<string, unknown> = {};\r\n    bKeys.forEach((k) => {\r\n      const value = replaceEqualDeep((a as any)[k], (b as any)[k]);\r\n      out[k] = value;\r\n      if (value !== (a as any)[k]) equal = false;\r\n    });\r\n    return (equal ? a : (out as T));\r\n  }\r\n  return b;\r\n};\r\n","import { RetryOptions } from \"../types\";\r\n\r\nexport const isAbortError = (e: unknown) => {\r\n  if (!e) return false;\r\n  const anyE = e as any;\r\n  return anyE?.name === \"AbortError\" || anyE?.code === 20;\r\n};\r\n\r\nexport const sleep = (ms: number) =>\r\n  new Promise<void>((resolve) => setTimeout(resolve, ms));\r\n\r\nexport const runWithRetry = async <T>(\r\n  fn: (attemptIndex: number) => Promise<T>,\r\n  retryCfg: RetryOptions,\r\n  onRetryBump: (n: number) => void,\r\n  onRetryEmit?: (attempt: number, attempts: number) => void\r\n): Promise<T> => {\r\n  const attempts = Math.max(1, retryCfg.attempts ?? 1);\r\n  const retryOn = retryCfg.retryOn ?? (() => true);\r\n  const delayCfg = retryCfg.delay ?? 0;\r\n\r\n  let lastErr: unknown;\r\n\r\n  for (let i = 0; i < attempts; i++) {\r\n    try {\r\n      if (i > 0) {\r\n        onRetryBump(1);\r\n        onRetryEmit?.(i + 1, attempts);\r\n      }\r\n      return await fn(i);\r\n    } catch (e) {\r\n      lastErr = e;\r\n      if (isAbortError(e)) throw e;\r\n      if (i === attempts - 1) break;\r\n      if (!retryOn(e, i + 1)) break;\r\n\r\n      const ms =\r\n        typeof delayCfg === \"function\"\r\n          ? delayCfg(i + 1)\r\n          : (delayCfg as number);\r\n      if (ms > 0) await sleep(ms);\r\n    }\r\n  }\r\n\r\n  throw lastErr;\r\n};\r\n","type IDBPayload = {\r\n  key: string;\r\n  value: unknown;\r\n};\r\n\r\nexport function idbOpen(dbName: string, storeName: string): Promise<IDBDatabase> {\r\n  return new Promise((resolve, reject) => {\r\n    const req = indexedDB.open(dbName, 1);\r\n    req.onupgradeneeded = () => {\r\n      const db = req.result;\r\n      if (!db.objectStoreNames.contains(storeName)) {\r\n        db.createObjectStore(storeName, { keyPath: \"key\" });\r\n      }\r\n    };\r\n    req.onsuccess = () => resolve(req.result);\r\n    req.onerror = () => reject(req.error);\r\n  });\r\n}\r\n\r\nexport async function idbSet(\r\n  dbName: string,\r\n  storeName: string,\r\n  key: string,\r\n  value: unknown\r\n) {\r\n  const db = await idbOpen(dbName, storeName);\r\n  await new Promise<void>((resolve, reject) => {\r\n    const tx = db.transaction(storeName, \"readwrite\");\r\n    tx.oncomplete = () => resolve();\r\n    tx.onerror = () => reject(tx.error);\r\n    tx.objectStore(storeName).put({ key, value } satisfies IDBPayload);\r\n  });\r\n  db.close();\r\n}\r\n\r\nexport async function idbGet<T>(\r\n  dbName: string,\r\n  storeName: string,\r\n  key: string\r\n): Promise<T | undefined> {\r\n  const db = await idbOpen(dbName, storeName);\r\n  const result = await new Promise<T | undefined>((resolve, reject) => {\r\n    const tx = db.transaction(storeName, \"readonly\");\r\n    tx.onerror = () => reject(tx.error);\r\n    const req = tx.objectStore(storeName).get(key);\r\n    req.onsuccess = () =>\r\n      resolve((req.result?.value ?? undefined) as T | undefined);\r\n    req.onerror = () => reject(req.error);\r\n  });\r\n  db.close();\r\n  return result;\r\n}\r\n","import { clearAuthToken, setAuthToken } from \"./token\";\r\nimport { useQueryStore } from \"../store/client\";\r\n\r\ntype BetterAuthSignIn<TEmail = unknown, TSocial = unknown, TOAuth2 = unknown> =\r\n  | ((payload: TEmail) => Promise<unknown>)\r\n  | {\r\n      email?: (payload: TEmail) => Promise<unknown>;\r\n      social?: (payload: TSocial) => Promise<unknown>;\r\n      oauth2?: (payload: TOAuth2) => Promise<unknown>;\r\n    };\r\n\r\ntype BetterAuthSignUp<TEmail = unknown> =\r\n  | ((payload: TEmail) => Promise<unknown>)\r\n  | {\r\n      email?: (payload: TEmail) => Promise<unknown>;\r\n    };\r\n\r\nexport type BetterAuthClient<\r\n  TSignIn = unknown,\r\n  TSignUp = unknown,\r\n  TSession = unknown,\r\n  TSocialSignIn = unknown,\r\n  TOAuth2SignIn = unknown,\r\n  TRequestPasswordReset = unknown,\r\n  TResetPassword = unknown,\r\n  TChangePassword = unknown,\r\n> = {\r\n  signIn?: BetterAuthSignIn<TSignIn, TSocialSignIn, TOAuth2SignIn>;\r\n  signUp?: BetterAuthSignUp<TSignUp>;\r\n  signOut?: () => Promise<unknown>;\r\n  getSession?: () => Promise<TSession | null | undefined>;\r\n  requestPasswordReset?: (payload: TRequestPasswordReset) => Promise<unknown>;\r\n  resetPassword?: (payload: TResetPassword) => Promise<unknown>;\r\n  changePassword?: (payload: TChangePassword) => Promise<unknown>;\r\n};\r\n\r\nexport type BetterAuthBridgeOptions = {\r\n  getTokenFromResult?: (result: unknown) => string | undefined;\r\n  getTokenFromSession?: (session: unknown) => string | undefined;\r\n  setToken?: (token?: string) => void;\r\n  clearCacheOnSignOut?: boolean;\r\n};\r\n\r\nconst resolveToken = (value: unknown) => {\r\n  if (!value || typeof value !== \"object\") return undefined;\r\n  const anyValue = value as any;\r\n  return (\r\n    anyValue.token ??\r\n    anyValue.accessToken ??\r\n    anyValue.session?.token ??\r\n    anyValue.session?.accessToken ??\r\n    anyValue.data?.token ??\r\n    anyValue.data?.session?.token\r\n  );\r\n};\r\n\r\nexport const createBetterAuthBridge = <\r\n  TSignIn = unknown,\r\n  TSignUp = unknown,\r\n  TSession = unknown,\r\n  TSocialSignIn = unknown,\r\n  TOAuth2SignIn = unknown,\r\n  TRequestPasswordReset = unknown,\r\n  TResetPassword = unknown,\r\n  TChangePassword = unknown,\r\n>(\r\n  client: BetterAuthClient<\r\n    TSignIn,\r\n    TSignUp,\r\n    TSession,\r\n    TSocialSignIn,\r\n    TOAuth2SignIn,\r\n    TRequestPasswordReset,\r\n    TResetPassword,\r\n    TChangePassword\r\n  >,\r\n  options?: BetterAuthBridgeOptions\r\n) => {\r\n  const setToken = options?.setToken ?? setAuthToken;\r\n  const getTokenFromResult = options?.getTokenFromResult ?? resolveToken;\r\n  const getTokenFromSession = options?.getTokenFromSession ?? resolveToken;\r\n  const clearCacheOnSignOut = options?.clearCacheOnSignOut ?? true;\r\n  const resolveSignInEmail = () => {\r\n    if (typeof client.signIn === \"function\") return client.signIn;\r\n    return client.signIn?.email;\r\n  };\r\n  const resolveSignInSocial = () => {\r\n    if (!client.signIn || typeof client.signIn === \"function\") return undefined;\r\n    return client.signIn.social;\r\n  };\r\n  const resolveSignInOAuth2 = () => {\r\n    if (!client.signIn || typeof client.signIn === \"function\") return undefined;\r\n    return client.signIn.oauth2;\r\n  };\r\n  const signUpEmail = () => {\r\n    if (typeof client.signUp === \"function\") return client.signUp;\r\n    return client.signUp?.email;\r\n  };\r\n\r\n  const syncFromResult = (result: unknown) => {\r\n    const token = getTokenFromResult(result);\r\n    if (token) setToken(token);\r\n    return result;\r\n  };\r\n\r\n  const refreshSession = async () => {\r\n    if (!client.getSession) return undefined;\r\n    const session = await client.getSession();\r\n    const token = getTokenFromSession(session);\r\n    setToken(token);\r\n    return session;\r\n  };\r\n\r\n  const register = async (payload: TSignUp) => {\r\n    const handler = signUpEmail();\r\n    if (!handler) {\r\n      throw new Error(\"better-auth client missing signUp.email\");\r\n    }\r\n    const result = await handler(payload);\r\n    return syncFromResult(result);\r\n  };\r\n\r\n  const signIn = async (payload: TSignIn) => {\r\n    const handler = resolveSignInEmail();\r\n    if (!handler) {\r\n      throw new Error(\"better-auth client missing signIn.email\");\r\n    }\r\n    const result = await handler(payload);\r\n    return syncFromResult(result);\r\n  };\r\n\r\n  const signInSocial = async (payload: TSocialSignIn) => {\r\n    const handler = resolveSignInSocial();\r\n    if (!handler) {\r\n      throw new Error(\"better-auth client missing signIn.social\");\r\n    }\r\n    const result = await handler(payload);\r\n    return syncFromResult(result);\r\n  };\r\n  const signInOAuth2 = async (payload: TOAuth2SignIn) => {\r\n    const handler = resolveSignInOAuth2();\r\n    if (!handler) {\r\n      throw new Error(\"better-auth client missing signIn.oauth2\");\r\n    }\r\n    const result = await handler(payload);\r\n    return syncFromResult(result);\r\n  };\r\n\r\n  const signOut = async () => {\r\n    const result = await client.signOut?.();\r\n    clearAuthToken();\r\n    if (clearCacheOnSignOut) {\r\n      useQueryStore.getState().clear();\r\n    }\r\n    return result;\r\n  };\r\n  const requestPasswordReset = async (payload: TRequestPasswordReset) => {\r\n    if (!client.requestPasswordReset) {\r\n      throw new Error(\"better-auth client missing requestPasswordReset\");\r\n    }\r\n    return client.requestPasswordReset(payload);\r\n  };\r\n  const resetPassword = async (payload: TResetPassword) => {\r\n    if (!client.resetPassword) {\r\n      throw new Error(\"better-auth client missing resetPassword\");\r\n    }\r\n    return client.resetPassword(payload);\r\n  };\r\n  const changePassword = async (payload: TChangePassword) => {\r\n    if (!client.changePassword) {\r\n      throw new Error(\"better-auth client missing changePassword\");\r\n    }\r\n    return client.changePassword(payload);\r\n  };\r\n\r\n  return {\r\n    client,\r\n    register,\r\n    signIn,\r\n    signInSocial,\r\n    signInOAuth2,\r\n    signOut,\r\n    refreshSession,\r\n    requestPasswordReset,\r\n    resetPassword,\r\n    changePassword,\r\n  };\r\n};\r\n","import { createBetterAuthBridge } from \"./betterAuth\";\r\n\r\nexport type AuthBridgeFromEnvOptions = {\r\n  baseURL?: string;\r\n  plugins?: unknown[];\r\n  clearCacheOnSignOut?: boolean;\r\n};\r\n\r\nconst resolveDefaultBaseURL = () => {\r\n  if (typeof window !== \"undefined\") {\r\n    return `${window.location.origin}/api/auth`;\r\n  }\r\n  return \"/api/auth\";\r\n};\r\n\r\nexport const createAuthBridgeFromEnv = async (\r\n  options: AuthBridgeFromEnvOptions = {}\r\n) => {\r\n  let createAuthClient: (opts: {\r\n    baseURL: string;\r\n    plugins?: unknown[];\r\n  }) => unknown;\r\n\r\n  try {\r\n    const mod = await import(\"better-auth/client\");\r\n    createAuthClient = (mod as any).createAuthClient;\r\n    if (!createAuthClient) {\r\n      throw new Error(\"better-auth/client did not export createAuthClient\");\r\n    }\r\n  } catch (error) {\r\n    throw new Error(\r\n      \"better-auth is required for createAuthBridgeFromEnv. Install it with `npm i better-auth`.\"\r\n    );\r\n  }\r\n\r\n  const client = createAuthClient({\r\n    baseURL: options.baseURL ?? resolveDefaultBaseURL(),\r\n    plugins: options.plugins,\r\n  });\r\n\r\n  return createBetterAuthBridge(client as any, {\r\n    clearCacheOnSignOut: options.clearCacheOnSignOut,\r\n  });\r\n};\r\n","import type { QueryKey, QueryStore } from \"../types\";\r\nimport { hashKey } from \"../utils/keys\";\r\nimport { useQueryStore } from \"../store\";\r\n\r\nexport type SocketLike = {\r\n  on: (event: string, handler: (payload: any) => void) => void;\r\n  off: (event: string, handler: (payload: any) => void) => void;\r\n};\r\n\r\nexport type SocketCacheEvent<TPayload = unknown> = {\r\n  event: string;\r\n  key: (payload: TPayload) => QueryKey;\r\n  update?: (prev: unknown | undefined, payload: TPayload) => unknown;\r\n  invalidate?: boolean;\r\n  setOptions?: {\r\n    staleTime?: number;\r\n    cacheTime?: number;\r\n    refetchInterval?: number;\r\n    tags?: string[];\r\n    meta?: unknown;\r\n    fetchedAt?: number;\r\n  };\r\n};\r\n\r\nexport type SocketCacheBridgeOptions = {\r\n  socket: SocketLike;\r\n  store?: { getState: () => QueryStore };\r\n  events: SocketCacheEvent[];\r\n  onError?: (error: unknown, payload: unknown, event: string) => void;\r\n};\r\n\r\nexport type SocketCacheConnection = {\r\n  socket: SocketLike & { disconnect?: () => void; close?: () => void };\r\n  start: () => void;\r\n  stop: () => void;\r\n  dispose: () => void;\r\n};\r\n\r\nexport type ConnectSocketCacheOptions = Omit<SocketCacheBridgeOptions, \"socket\"> & {\r\n  url: string;\r\n  socketOptions?: Record<string, unknown>;\r\n  autoStart?: boolean;\r\n};\r\n\r\nexport const createSocketCacheBridge = (options: SocketCacheBridgeOptions) => {\r\n  const store = options.store ?? useQueryStore;\r\n  const handlers = new Map<string, Array<(payload: any) => void>>();\r\n\r\n  const start = () => {\r\n    options.events.forEach((evt) => {\r\n      const handler = (payload: unknown) => {\r\n        try {\r\n          const key = evt.key(payload);\r\n          if (evt.invalidate) {\r\n            store.getState().invalidate(key);\r\n            return;\r\n          }\r\n          if (!evt.update) return;\r\n          const hashedKey = hashKey(key);\r\n          const prev = store.getState().queries[hashedKey]?.data;\r\n          const next = evt.update(prev, payload);\r\n          store.getState().setQueryData(key, next, evt.setOptions);\r\n        } catch (error) {\r\n          options.onError?.(error, payload, evt.event);\r\n        }\r\n      };\r\n      const list = handlers.get(evt.event) ?? [];\r\n      list.push(handler);\r\n      handlers.set(evt.event, list);\r\n      options.socket.on(evt.event, handler);\r\n    });\r\n  };\r\n\r\n  const stop = () => {\r\n    handlers.forEach((list, event) => {\r\n      list.forEach((handler) => {\r\n        options.socket.off(event, handler);\r\n      });\r\n    });\r\n    handlers.clear();\r\n  };\r\n\r\n  return { start, stop };\r\n};\r\n\r\nexport const connectSocketCache = async (\r\n  options: ConnectSocketCacheOptions\r\n): Promise<SocketCacheConnection> => {\r\n  const { url, socketOptions, autoStart = true, ...bridgeOptions } = options;\r\n\r\n  let ioFactory: (\r\n    url: string,\r\n    opts?: Record<string, unknown>\r\n  ) => SocketLike & { disconnect?: () => void; close?: () => void };\r\n\r\n  try {\r\n    const mod = await import(\"socket.io-client\");\r\n    ioFactory = (mod as any).io;\r\n    if (!ioFactory) {\r\n      throw new Error(\"socket.io-client did not export io()\");\r\n    }\r\n  } catch {\r\n    throw new Error(\r\n      \"socket.io-client is required for connectSocketCache. Install it with `npm i socket.io-client`.\"\r\n    );\r\n  }\r\n\r\n  const socket = ioFactory(url, socketOptions);\r\n  const bridge = createSocketCacheBridge({\r\n    ...bridgeOptions,\r\n    socket,\r\n  });\r\n\r\n  if (autoStart) bridge.start();\r\n\r\n  const dispose = () => {\r\n    bridge.stop();\r\n    if (typeof (socket as any).disconnect === \"function\") {\r\n      (socket as any).disconnect();\r\n      return;\r\n    }\r\n    if (typeof (socket as any).close === \"function\") {\r\n      (socket as any).close();\r\n    }\r\n  };\r\n\r\n  return {\r\n    socket,\r\n    start: bridge.start,\r\n    stop: bridge.stop,\r\n    dispose,\r\n  };\r\n};\r\n","import type { QueryKey, QueryStore } from \"../types\";\r\nimport { hashKey } from \"../utils/keys\";\r\nimport { useQueryStore } from \"../store\";\r\n\r\nexport type EventSourceLike = {\r\n  addEventListener: (event: string, handler: (event: MessageEvent) => void) => void;\r\n  removeEventListener: (\r\n    event: string,\r\n    handler: (event: MessageEvent) => void\r\n  ) => void;\r\n  close?: () => void;\r\n};\r\n\r\nexport type SseCacheEvent<TPayload = unknown> = {\r\n  event: string;\r\n  key: (payload: TPayload) => QueryKey;\r\n  update?: (prev: unknown | undefined, payload: TPayload) => unknown;\r\n  invalidate?: boolean;\r\n  parse?: (event: MessageEvent) => TPayload;\r\n  setOptions?: {\r\n    staleTime?: number;\r\n    cacheTime?: number;\r\n    refetchInterval?: number;\r\n    tags?: string[];\r\n    meta?: unknown;\r\n    fetchedAt?: number;\r\n  };\r\n};\r\n\r\nexport type SseCacheBridgeOptions = {\r\n  source: EventSourceLike;\r\n  store?: { getState: () => QueryStore };\r\n  events: SseCacheEvent[];\r\n  parse?: (event: MessageEvent) => unknown;\r\n  onError?: (error: unknown, event: MessageEvent, name: string) => void;\r\n};\r\n\r\nexport type SseCacheConnection = {\r\n  source: EventSourceLike;\r\n  start: () => void;\r\n  stop: () => void;\r\n  dispose: () => void;\r\n};\r\n\r\nexport type ConnectSseCacheOptions = Omit<SseCacheBridgeOptions, \"source\"> & {\r\n  url: string;\r\n  eventSourceInit?: EventSourceInit;\r\n  autoStart?: boolean;\r\n};\r\n\r\nconst defaultParse = (event: MessageEvent) => {\r\n  if (typeof event.data !== \"string\") return event.data;\r\n  try {\r\n    return JSON.parse(event.data);\r\n  } catch {\r\n    return event.data;\r\n  }\r\n};\r\n\r\nexport const createSseCacheBridge = (options: SseCacheBridgeOptions) => {\r\n  const store = options.store ?? useQueryStore;\r\n  const handlers = new Map<string, Array<(event: MessageEvent) => void>>();\r\n\r\n  const start = () => {\r\n    options.events.forEach((evt) => {\r\n      const handler = (event: MessageEvent) => {\r\n        try {\r\n          const parser = evt.parse ?? options.parse ?? defaultParse;\r\n          const payload = parser(event) as unknown;\r\n          const key = evt.key(payload as any);\r\n          if (evt.invalidate) {\r\n            store.getState().invalidate(key);\r\n            return;\r\n          }\r\n          if (!evt.update) return;\r\n          const hashedKey = hashKey(key);\r\n          const prev = store.getState().queries[hashedKey]?.data;\r\n          const next = evt.update(prev, payload as any);\r\n          store.getState().setQueryData(key, next, evt.setOptions);\r\n        } catch (error) {\r\n          options.onError?.(error, event, evt.event);\r\n        }\r\n      };\r\n      const list = handlers.get(evt.event) ?? [];\r\n      list.push(handler);\r\n      handlers.set(evt.event, list);\r\n      options.source.addEventListener(evt.event, handler);\r\n    });\r\n  };\r\n\r\n  const stop = () => {\r\n    handlers.forEach((list, event) => {\r\n      list.forEach((handler) => {\r\n        options.source.removeEventListener(event, handler);\r\n      });\r\n    });\r\n    handlers.clear();\r\n  };\r\n\r\n  return { start, stop };\r\n};\r\n\r\nexport const connectSseCache = (options: ConnectSseCacheOptions): SseCacheConnection => {\r\n  const { url, eventSourceInit, autoStart = true, ...bridgeOptions } = options;\r\n  if (typeof EventSource === \"undefined\") {\r\n    throw new Error(\"EventSource is not available in this environment.\");\r\n  }\r\n  const source = new EventSource(url, eventSourceInit);\r\n  const bridge = createSseCacheBridge({ ...bridgeOptions, source });\r\n  if (autoStart) bridge.start();\r\n\r\n  const dispose = () => {\r\n    bridge.stop();\r\n    source.close?.();\r\n  };\r\n\r\n  return {\r\n    source,\r\n    start: bridge.start,\r\n    stop: bridge.stop,\r\n    dispose,\r\n  };\r\n};\r\n","import type { QueryKey } from \"../types\";\r\nimport { createSocketCacheBridge, SocketLike } from \"./socket\";\r\n\r\nexport type ChatBridgeOptions<TMessage, TPresence, TTyping> = {\r\n  socket: SocketLike;\r\n  roomId: string;\r\n  messageKey?: QueryKey;\r\n  presenceKey?: QueryKey;\r\n  typingKey?: QueryKey;\r\n  getMessageId?: (message: TMessage) => unknown;\r\n  events?: {\r\n    message?: string;\r\n    presence?: string;\r\n    typing?: string;\r\n  };\r\n  onError?: (error: unknown, payload: unknown, event: string) => void;\r\n};\r\n\r\nconst dedupeById = <T>(list: T[], getId?: (item: T) => unknown) => {\r\n  if (!getId) return list;\r\n  const seen = new Set<unknown>();\r\n  return list.filter((item) => {\r\n    const id = getId(item);\r\n    if (id === undefined || id === null) return true;\r\n    if (seen.has(id)) return false;\r\n    seen.add(id);\r\n    return true;\r\n  });\r\n};\r\n\r\nexport const createChatRoomBridge = <\r\n  TMessage = unknown,\r\n  TPresence = unknown,\r\n  TTyping = unknown\r\n>(\r\n  options: ChatBridgeOptions<TMessage, TPresence, TTyping>\r\n) => {\r\n  const messageEvent = options.events?.message ?? \"message:new\";\r\n  const presenceEvent = options.events?.presence ?? \"presence:update\";\r\n  const typingEvent = options.events?.typing ?? \"typing:update\";\r\n  const messageKey = options.messageKey ?? [\"messages\", options.roomId];\r\n  const presenceKey = options.presenceKey ?? [\"presence\", options.roomId];\r\n  const typingKey = options.typingKey ?? [\"typing\", options.roomId];\r\n\r\n  return createSocketCacheBridge({\r\n    socket: options.socket,\r\n    events: [\r\n      {\r\n        event: messageEvent,\r\n        key: () => messageKey,\r\n        update: (prev, payload) => {\r\n          const list = Array.isArray(prev) ? (prev as TMessage[]) : [];\r\n          const next = [...list, payload as TMessage];\r\n          return dedupeById(next, options.getMessageId);\r\n        },\r\n      },\r\n      {\r\n        event: presenceEvent,\r\n        key: () => presenceKey,\r\n        update: (_prev, payload) => payload as TPresence,\r\n      },\r\n      {\r\n        event: typingEvent,\r\n        key: () => typingKey,\r\n        update: (_prev, payload) => payload as TTyping,\r\n      },\r\n    ],\r\n    onError: options.onError,\r\n  });\r\n};\r\n","export type SignalingTransport = {\r\n  on: (event: string, handler: (payload: any) => void) => void;\r\n  off: (event: string, handler: (payload: any) => void) => void;\r\n  emit: (event: string, payload: any) => void;\r\n};\r\n\r\nexport type WebRtcSignal = {\r\n  roomId: string;\r\n  from: string;\r\n  to?: string;\r\n  description?: RTCSessionDescriptionInit;\r\n  candidate?: RTCIceCandidateInit;\r\n};\r\n\r\nexport type WebRtcPeerOptions = {\r\n  id: string;\r\n  roomId: string;\r\n  onSignal: (payload: WebRtcSignal) => void;\r\n  onTrack?: (event: RTCTrackEvent) => void;\r\n  onData?: (data: string) => void;\r\n  onStateChange?: (state: RTCPeerConnectionState) => void;\r\n  iceServers?: RTCIceServer[];\r\n  stream?: MediaStream | null;\r\n};\r\n\r\nexport const createWebRtcPeer = (options: WebRtcPeerOptions) => {\r\n  const pc = new RTCPeerConnection({\r\n    iceServers: options.iceServers ?? [],\r\n  });\r\n\r\n  let dataChannel: RTCDataChannel | null = null;\r\n\r\n  if (options.stream) {\r\n    options.stream.getTracks().forEach((track) => {\r\n      pc.addTrack(track, options.stream as MediaStream);\r\n    });\r\n  }\r\n\r\n  pc.ontrack = (event) => options.onTrack?.(event);\r\n  pc.onconnectionstatechange = () =>\r\n    options.onStateChange?.(pc.connectionState);\r\n  pc.onicecandidate = (event) => {\r\n    if (!event.candidate) return;\r\n    options.onSignal({\r\n      roomId: options.roomId,\r\n      from: options.id,\r\n      candidate: event.candidate.toJSON(),\r\n    });\r\n  };\r\n\r\n  pc.ondatachannel = (event) => {\r\n    dataChannel = event.channel;\r\n    dataChannel.onmessage = (msg) => options.onData?.(String(msg.data));\r\n  };\r\n\r\n  const ensureDataChannel = () => {\r\n    if (dataChannel) return;\r\n    dataChannel = pc.createDataChannel(\"chat\");\r\n    dataChannel.onmessage = (msg) => options.onData?.(String(msg.data));\r\n  };\r\n\r\n  const start = async () => {\r\n    ensureDataChannel();\r\n    const offer = await pc.createOffer();\r\n    await pc.setLocalDescription(offer);\r\n    options.onSignal({\r\n      roomId: options.roomId,\r\n      from: options.id,\r\n      description: pc.localDescription ?? offer,\r\n    });\r\n  };\r\n\r\n  const handleSignal = async (payload: WebRtcSignal) => {\r\n    if (payload.from === options.id) return;\r\n    if (payload.roomId !== options.roomId) return;\r\n\r\n    if (payload.description) {\r\n      await pc.setRemoteDescription(payload.description);\r\n      if (payload.description.type === \"offer\") {\r\n        const answer = await pc.createAnswer();\r\n        await pc.setLocalDescription(answer);\r\n        options.onSignal({\r\n          roomId: options.roomId,\r\n          from: options.id,\r\n          description: pc.localDescription ?? answer,\r\n        });\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (payload.candidate) {\r\n      try {\r\n        await pc.addIceCandidate(payload.candidate);\r\n      } catch {\r\n        // ignore\r\n      }\r\n    }\r\n  };\r\n\r\n  const sendData = (data: string) => {\r\n    dataChannel?.send(data);\r\n  };\r\n\r\n  const close = () => {\r\n    dataChannel?.close();\r\n    dataChannel = null;\r\n    pc.close();\r\n  };\r\n\r\n  return { pc, start, handleSignal, sendData, close };\r\n};\r\n\r\n","import { useQueryStore } from \"../store\";\r\n\r\nexport type StoreEventDetail = {\r\n  type: string;\r\n  payload: unknown;\r\n  ts: number;\r\n};\r\n\r\nexport type StoreEventReporterOptions = {\r\n  eventName?: string;\r\n  onEvent: (event: StoreEventDetail) => void;\r\n};\r\n\r\nexport const createStoreEventReporter = (\r\n  options: StoreEventReporterOptions\r\n) => {\r\n  if (typeof window === \"undefined\") {\r\n    return () => {};\r\n  }\r\n  const eventName =\r\n    options.eventName ?? useQueryStore.getState().config.devtools.eventName;\r\n\r\n  const handler = (event: Event) => {\r\n    const detail = (event as CustomEvent).detail as StoreEventDetail | undefined;\r\n    if (!detail) return;\r\n    options.onEvent(detail);\r\n  };\r\n\r\n  window.addEventListener(eventName, handler);\r\n  return () => {\r\n    window.removeEventListener(eventName, handler);\r\n  };\r\n};\r\n","import type { QueryFetcher, QueryKey } from \"../types\";\r\n\r\nexport type FetchTrace = {\r\n  key?: QueryKey;\r\n  label?: string;\r\n  start: number;\r\n  end: number;\r\n  duration: number;\r\n  success: boolean;\r\n  error?: unknown;\r\n};\r\n\r\nexport type FetchTraceHandlers = {\r\n  onStart?: (info: { key?: QueryKey; label?: string }) => void;\r\n  onSuccess?: (info: FetchTrace) => void;\r\n  onError?: (info: FetchTrace) => void;\r\n  onSettled?: (info: FetchTrace) => void;\r\n};\r\n\r\nexport const wrapFetcher = <T>(\r\n  fetcher: QueryFetcher<T>,\r\n  handlers: FetchTraceHandlers,\r\n  meta?: { key?: QueryKey; label?: string }\r\n): QueryFetcher<T> => {\r\n  return async (ctx?: { signal?: AbortSignal }) => {\r\n    const start = Date.now();\r\n    handlers.onStart?.({ key: meta?.key, label: meta?.label });\r\n    try {\r\n      const fn = fetcher as any;\r\n      const result =\r\n        typeof fn === \"function\" && fn.length >= 1 ? fn(ctx) : fn();\r\n      const data = await result;\r\n      const end = Date.now();\r\n      const trace: FetchTrace = {\r\n        key: meta?.key,\r\n        label: meta?.label,\r\n        start,\r\n        end,\r\n        duration: end - start,\r\n        success: true,\r\n      };\r\n      handlers.onSuccess?.(trace);\r\n      handlers.onSettled?.(trace);\r\n      return data;\r\n    } catch (error) {\r\n      const end = Date.now();\r\n      const trace: FetchTrace = {\r\n        key: meta?.key,\r\n        label: meta?.label,\r\n        start,\r\n        end,\r\n        duration: end - start,\r\n        success: false,\r\n        error,\r\n      };\r\n      handlers.onError?.(trace);\r\n      handlers.onSettled?.(trace);\r\n      throw error;\r\n    }\r\n  };\r\n};\r\n","import { FetchQueryOptions, QueryKey } from \"../types\";\r\nimport { hashKey } from \"../utils/keys\";\r\nimport { useQueryStore } from \"../store\";\r\n\r\nexport type PrefetchTask<T> = {\r\n  key: QueryKey;\r\n  options: FetchQueryOptions<T>;\r\n};\r\n\r\nexport type PrefetchSchedulerOptions = {\r\n  concurrency?: number;\r\n  delayMs?: number;\r\n  dedupe?: boolean;\r\n  maxPerSecond?: number;\r\n};\r\n\r\nexport const createPrefetchScheduler = (\r\n  options: PrefetchSchedulerOptions = {}\r\n) => {\r\n  const concurrency = Math.max(1, options.concurrency ?? 2);\r\n  const delayMs = Math.max(0, options.delayMs ?? 0);\r\n  const dedupe = options.dedupe ?? true;\r\n  const maxPerSecond = Math.max(0, options.maxPerSecond ?? 0);\r\n\r\n  const queue: Array<PrefetchTask<any>> = [];\r\n  const pending = new Set<string>();\r\n  let active = 0;\r\n  let draining = false;\r\n  let tokens = maxPerSecond > 0 ? maxPerSecond : Infinity;\r\n\r\n  const drain = () => {\r\n    if (draining) return;\r\n    draining = true;\r\n    if (maxPerSecond > 0 && typeof window !== \"undefined\") {\r\n      window.setInterval(() => {\r\n        tokens = maxPerSecond;\r\n      }, 1000);\r\n    }\r\n    const step = () => {\r\n      while (active < concurrency && queue.length > 0 && tokens > 0) {\r\n        const task = queue.shift()!;\r\n        const hashedKey = hashKey(task.key);\r\n        if (dedupe) pending.delete(hashedKey);\r\n        active += 1;\r\n        if (maxPerSecond > 0) tokens -= 1;\r\n        useQueryStore\r\n          .getState()\r\n          .prefetchQuery(task.key, task.options)\r\n          .catch(() => {})\r\n          .finally(() => {\r\n            active -= 1;\r\n            if (queue.length > 0) {\r\n              if (delayMs > 0) {\r\n                setTimeout(step, delayMs);\r\n              } else {\r\n                step();\r\n              }\r\n            } else {\r\n              draining = false;\r\n            }\r\n          });\r\n      }\r\n      if (queue.length === 0) {\r\n        draining = false;\r\n      }\r\n    };\r\n    step();\r\n  };\r\n\r\n  const schedule = <T>(key: QueryKey, options: FetchQueryOptions<T>) => {\r\n    const hashedKey = hashKey(key);\r\n    if (dedupe && pending.has(hashedKey)) {\r\n      return () => {};\r\n    }\r\n    if (dedupe) pending.add(hashedKey);\r\n    queue.push({ key, options });\r\n    drain();\r\n    return () => {\r\n      const idx = queue.findIndex(\r\n        (item) => hashKey(item.key) === hashedKey\r\n      );\r\n      if (idx >= 0) queue.splice(idx, 1);\r\n      if (dedupe) pending.delete(hashedKey);\r\n    };\r\n  };\r\n\r\n  const clear = () => {\r\n    queue.length = 0;\r\n    pending.clear();\r\n  };\r\n\r\n  return { schedule, clear };\r\n};\r\n","import { useQueryStore } from \"./client\";\r\n\r\nexport type CacheVersionGuardOptions = {\r\n  version: string;\r\n  storage?: \"local\" | \"session\";\r\n  channelName?: string;\r\n  clearOnMismatch?: boolean;\r\n  onMismatch?: (previous: string | null, next: string) => void;\r\n};\r\n\r\nexport const createCacheVersionGuard = (options: CacheVersionGuardOptions) => {\r\n  if (typeof window === \"undefined\") {\r\n    return { previousVersion: null as string | null, dispose: () => {} };\r\n  }\r\n\r\n  const storage =\r\n    options.storage === \"session\" ? window.sessionStorage : window.localStorage;\r\n  const persistenceKey =\r\n    useQueryStore.getState().config.persistence.storageKey;\r\n  const versionKey = `${persistenceKey}::version`;\r\n  const previous = storage.getItem(versionKey);\r\n  const next = options.version;\r\n  const clearOnMismatch = options.clearOnMismatch ?? true;\r\n\r\n  if (previous !== next) {\r\n    if (clearOnMismatch) {\r\n      useQueryStore.getState().clear();\r\n    }\r\n    options.onMismatch?.(previous, next);\r\n    storage.setItem(versionKey, next);\r\n  }\r\n\r\n  const channelName = options.channelName ?? \"yokai-query-cache\";\r\n  if (typeof BroadcastChannel === \"undefined\") {\r\n    return { previousVersion: previous, dispose: () => {} };\r\n  }\r\n\r\n  const channel = new BroadcastChannel(channelName);\r\n  const handler = (event: MessageEvent) => {\r\n    const data = event.data as { type?: string; version?: string } | undefined;\r\n    if (!data || data.type !== \"cache:version\") return;\r\n    if (data.version !== next && clearOnMismatch) {\r\n      useQueryStore.getState().clear();\r\n    }\r\n  };\r\n\r\n  channel.addEventListener(\"message\", handler);\r\n  channel.postMessage({ type: \"cache:version\", version: next });\r\n\r\n  const dispose = () => {\r\n    channel.removeEventListener(\"message\", handler);\r\n    channel.close();\r\n  };\r\n\r\n  return { previousVersion: previous, dispose };\r\n};\r\n","import { useQueryStore } from \"./client\";\r\nimport { QueryEntry, QueryKey } from \"../types\";\r\nimport { hashKey } from \"../utils/keys\";\r\n\r\nexport type CacheSnapshot = {\r\n  version: number;\r\n  createdAt: number;\r\n  entries: Record<string, Omit<QueryEntry, \"fetcher\">>;\r\n};\r\n\r\nexport const exportCacheSnapshot = (): CacheSnapshot => {\r\n  const state = useQueryStore.getState();\r\n  const entries: Record<string, Omit<QueryEntry, \"fetcher\">> = {};\r\n  Object.entries(state.queries).forEach(([key, entry]) => {\r\n    const { fetcher: _f, error: _e, ...rest } = entry;\r\n    entries[key] = rest;\r\n  });\r\n  return { version: 1, createdAt: Date.now(), entries };\r\n};\r\n\r\nexport const importCacheSnapshot = (snapshot: CacheSnapshot) => {\r\n  if (!snapshot?.entries) return;\r\n  const next = Object.fromEntries(\r\n    Object.entries(snapshot.entries).map(([k, entry]) => {\r\n      return [\r\n        k,\r\n        {\r\n          ...entry,\r\n          staleTime: entry.staleTime,\r\n          cacheTime: entry.cacheTime,\r\n        } as QueryEntry,\r\n      ];\r\n    })\r\n  );\r\n  useQueryStore.setState({ queries: next });\r\n};\r\n\r\nexport const setSnapshotEntry = (key: QueryKey, entry: QueryEntry) => {\r\n  const hashedKey = hashKey(key);\r\n  useQueryStore.setState((state) => ({\r\n    queries: { ...state.queries, [hashedKey]: entry },\r\n  }));\r\n};\r\n","import { useQueryStore } from \"../store\";\r\n\r\nexport type OfflineMutation<TVars, TResult> = {\r\n  key: string;\r\n  vars: TVars;\r\n  run: (vars: TVars) => Promise<TResult>;\r\n};\r\n\r\nexport type OfflineQueueOptions = {\r\n  storageKey?: string;\r\n  autoFlush?: boolean;\r\n};\r\n\r\nexport const createOfflineMutationQueue = (options: OfflineQueueOptions = {}) => {\r\n  const storageKey = options.storageKey ?? \"__yokai_offline_queue__\";\r\n  const queue: OfflineMutation<any, any>[] = [];\r\n\r\n  const load = () => {\r\n    if (typeof window === \"undefined\") return;\r\n    const raw = window.localStorage.getItem(storageKey);\r\n    if (!raw) return;\r\n    try {\r\n      const parsed = JSON.parse(raw) as Array<{ key: string; vars: unknown }>;\r\n      parsed.forEach((item) => {\r\n        queue.push({\r\n          key: item.key,\r\n          vars: item.vars,\r\n          run: async () => {\r\n            throw new Error(\"Offline queue item missing run()\");\r\n          },\r\n        });\r\n      });\r\n    } catch {\r\n      // ignore\r\n    }\r\n  };\r\n\r\n  const persist = () => {\r\n    if (typeof window === \"undefined\") return;\r\n    const snapshot = queue.map((item) => ({ key: item.key, vars: item.vars }));\r\n    window.localStorage.setItem(storageKey, JSON.stringify(snapshot));\r\n  };\r\n\r\n  const enqueue = <TVars, TResult>(\r\n    key: string,\r\n    vars: TVars,\r\n    run: (vars: TVars) => Promise<TResult>\r\n  ) => {\r\n    queue.push({ key, vars, run });\r\n    persist();\r\n  };\r\n\r\n  const flush = async () => {\r\n    const snapshot = [...queue];\r\n    queue.length = 0;\r\n    persist();\r\n    for (const item of snapshot) {\r\n      try {\r\n        await item.run(item.vars);\r\n      } catch {\r\n        queue.push(item);\r\n      }\r\n    }\r\n    persist();\r\n  };\r\n\r\n  if (options.autoFlush && typeof window !== \"undefined\") {\r\n    window.addEventListener(\"online\", () => {\r\n      flush().catch(() => {});\r\n    });\r\n  }\r\n\r\n  load();\r\n\r\n  return { enqueue, flush, size: () => queue.length };\r\n};\r\n","import { QueryKey } from \"../types\";\r\nimport { useQueryStore } from \"../store\";\r\nimport { hashKey } from \"../utils/keys\";\r\n\r\nexport type PresenceEntry = {\r\n  id: string;\r\n  name?: string;\r\n  status?: string;\r\n  lastSeen?: number;\r\n};\r\n\r\nexport type PresenceTtlOptions = {\r\n  key: QueryKey;\r\n  ttlMs: number;\r\n  intervalMs?: number;\r\n  getId?: (entry: PresenceEntry) => string;\r\n  onEvict?: (evicted: PresenceEntry[]) => void;\r\n};\r\n\r\nexport const startPresenceTtl = (options: PresenceTtlOptions) => {\r\n  const interval = Math.max(1000, options.intervalMs ?? 5_000);\r\n  const hashedKey = hashKey(options.key);\r\n  const getId = options.getId ?? ((entry: PresenceEntry) => entry.id);\r\n\r\n  const tick = () => {\r\n    const state = useQueryStore.getState();\r\n    const prev = state.queries[hashedKey]?.data;\r\n    const list = Array.isArray(prev) ? (prev as PresenceEntry[]) : [];\r\n    const now = Date.now();\r\n    const [keep, evicted] = list.reduce<\r\n      [PresenceEntry[], PresenceEntry[]]\r\n    >(\r\n      (acc, entry) => {\r\n        const lastSeen = entry.lastSeen ?? 0;\r\n        if (now - lastSeen <= options.ttlMs) {\r\n          acc[0].push(entry);\r\n        } else {\r\n          acc[1].push(entry);\r\n        }\r\n        return acc;\r\n      },\r\n      [[], []]\r\n    );\r\n\r\n    if (evicted.length > 0) {\r\n      state.setQueryData(options.key, keep, {\r\n        tags: state.queries[hashedKey]?.tags,\r\n      });\r\n      options.onEvict?.(evicted);\r\n    }\r\n  };\r\n\r\n  const timer = window.setInterval(tick, interval);\r\n  return () => window.clearInterval(timer);\r\n};\r\n","import { QueryKey } from \"../types\";\r\nimport { useQueryStore } from \"../store\";\r\nimport { hashKey } from \"../utils/keys\";\r\n\r\nexport type ReadReceipt = {\r\n  messageId: string;\r\n  userId: string;\r\n  readAt: number;\r\n};\r\n\r\nexport type ReadReceiptOptions = {\r\n  key: QueryKey;\r\n};\r\n\r\nexport const addReadReceipt = (receipt: ReadReceipt, options: ReadReceiptOptions) => {\r\n  const state = useQueryStore.getState();\r\n  const hashedKey = hashKey(options.key);\r\n  const prev = state.queries[hashedKey]?.data;\r\n  const list = Array.isArray(prev) ? (prev as ReadReceipt[]) : [];\r\n  const exists = list.some(\r\n    (item) =>\r\n      item.messageId === receipt.messageId && item.userId === receipt.userId\r\n  );\r\n  if (exists) return;\r\n  state.setQueryData(options.key, [...list, receipt], {\r\n    tags: state.queries[hashedKey]?.tags,\r\n  });\r\n};\r\n","import { QueryKey } from \"../types\";\r\nimport { hashKey } from \"../utils/keys\";\r\nimport { useQueryStore } from \"../store\";\r\n\r\nexport type SetListCacheOptions<T> = {\r\n  prepend?: boolean;\r\n  idKey?: keyof T;\r\n  unique?: boolean;\r\n  setOptions?: {\r\n    staleTime?: number;\r\n    cacheTime?: number;\r\n    refetchInterval?: number;\r\n    tags?: string[];\r\n    meta?: unknown;\r\n    fetchedAt?: number;\r\n  };\r\n};\r\n\r\nexport function setListCache<T>(\r\n  key: QueryKey,\r\n  item: T,\r\n  options?: SetListCacheOptions<T>\r\n) {\r\n  const state = useQueryStore.getState();\r\n  const hashedKey = hashKey(key);\r\n  const prev = state.queries[hashedKey]?.data;\r\n  const list = Array.isArray(prev) ? (prev as T[]) : [];\r\n  const next = options?.prepend ? [item, ...list] : [...list, item];\r\n\r\n  let deduped = next;\r\n  if (options?.idKey && options.unique !== false) {\r\n    const seen = new Set<unknown>();\r\n    deduped = next.filter((entry) => {\r\n      const id = entry?.[options.idKey as keyof T];\r\n      if (id === undefined || id === null) return true;\r\n      if (seen.has(id)) return false;\r\n      seen.add(id);\r\n      return true;\r\n    });\r\n  }\r\n\r\n  state.setQueryData(key, deduped, options?.setOptions);\r\n}\r\n","import { QueryClientConfigUpdate } from \"../types\";\r\nimport { createQueryClient } from \"../store\";\r\n\r\nexport const createDefaultClient = (overrides?: QueryClientConfigUpdate) =>\r\n  createQueryClient(overrides);\r\n","import { useEffect, useRef } from \"react\";\r\nimport { QueryFetcher, QueryKey, QueryDefaultOptions, RetryOptions } from \"../types\";\r\nimport { DEFAULT_CACHE_TIME, DEFAULT_STALE_TIME } from \"../store/defaults\";\r\nimport { hashKey, keyToString } from \"../utils/keys\";\r\nimport { useQueryStore } from \"../store\";\r\n\r\nexport type UseQueryReturn<T, R> = {\r\n  data: R | undefined;\r\n  error: unknown;\r\n  isLoading: boolean;\r\n  isFetching: boolean;\r\n  isStale: boolean;\r\n  refetch: (opts?: { background?: boolean }) => Promise<T | undefined>;\r\n};\r\n\r\nexport type UseQueryOptions<T, R> = {\r\n  select?: (data: T) => R;\r\n  fetcher?: QueryFetcher<T>;\r\n  enabled?: boolean;\r\n  suspense?: boolean;\r\n  throwOnError?: boolean;\r\n  background?: boolean;\r\n  keepPreviousData?: boolean;\r\n  initialData?: T | (() => T);\r\n  placeholderData?: R | ((prev: R | undefined) => R);\r\n  onSuccess?: (data: T) => void;\r\n  onError?: (error: unknown) => void;\r\n  onSettled?: (data: T | undefined, error: unknown | undefined) => void;\r\n  meta?: unknown;\r\n  staleTime?: number;\r\n  cacheTime?: number;\r\n  refetchInterval?: number;\r\n  tags?: string[];\r\n  retry?: RetryOptions;\r\n  abortOnNewFetch?: boolean;\r\n};\r\n\r\nexport function useQuery<T, R = T>(\r\n  key: QueryKey,\r\n  selectOrOptions?: ((data: T) => R) | UseQueryOptions<T, R>\r\n): UseQueryReturn<T, R> {\r\n  const resolvedKey = hashKey(key);\r\n  const options: UseQueryOptions<T, R> =\r\n    typeof selectOrOptions === \"function\"\r\n      ? { select: selectOrOptions }\r\n      : selectOrOptions ?? {};\r\n\r\n  const select = options.select;\r\n  const config = useQueryStore.getState().config;\r\n  const selectMemoMaxEntries = config.selectMemoMaxEntries ?? 0;\r\n  const defaults = (config.queryDefaults ?? []).reduce<QueryDefaultOptions>(\r\n    (acc, entry) => {\r\n      if (keyToString(key).startsWith(entry.prefix)) {\r\n        return { ...acc, ...entry.options };\r\n      }\r\n      return acc;\r\n    },\r\n    {}\r\n  );\r\n  const {\r\n    initialData: defaultInitialData,\r\n    placeholderData: defaultPlaceholderData,\r\n    ...restDefaults\r\n  } = defaults;\r\n  const mergedOptions: UseQueryOptions<T, R> = {\r\n    ...(restDefaults as Omit<UseQueryOptions<T, R>, \"initialData\" | \"placeholderData\">),\r\n    ...options,\r\n    retry: options.retry ?? defaults.retry,\r\n    tags: options.tags ?? defaults.tags,\r\n    refetchInterval: options.refetchInterval ?? defaults.refetchInterval,\r\n    abortOnNewFetch: options.abortOnNewFetch ?? defaults.abortOnNewFetch,\r\n    staleTime: options.staleTime ?? defaults.staleTime,\r\n    cacheTime: options.cacheTime ?? defaults.cacheTime,\r\n    initialData:\r\n      options.initialData ??\r\n      (defaultInitialData as T | (() => T) | undefined),\r\n    placeholderData:\r\n      options.placeholderData ??\r\n      (defaultPlaceholderData as R | ((prev: R | undefined) => R) | undefined),\r\n  };\r\n  const suspense = mergedOptions.suspense ?? config.suspense;\r\n  const throwOnError = mergedOptions.throwOnError ?? config.throwOnError;\r\n  const keepPreviousData = mergedOptions.keepPreviousData ?? false;\r\n  const previousDataRef = useRef<R | undefined>(undefined);\r\n  const previousKeyRef = useRef<string | undefined>(undefined);\r\n  const initialDataAppliedRef = useRef<string | undefined>(undefined);\r\n  const initialDataRef = useRef<{ key: string; value: T } | null>(null);\r\n  const fetcherRef = useRef<QueryFetcher<T> | undefined>(mergedOptions.fetcher);\r\n\r\n  const entry = useQueryStore((state) => state.queries[resolvedKey]);\r\n  const isFetching = useQueryStore((state) => !!state.inFlight[resolvedKey]);\r\n  let selected: any = entry?.data as T | undefined;\r\n\r\n  if (entry?.data !== undefined && select && selectMemoMaxEntries > 0) {\r\n    const memo = (useQueryStore as any).__selectMemo as\r\n      | Map<string, { selectRef: Function; inputRef: unknown; output: unknown }>\r\n      | undefined;\r\n\r\n    if (!memo) {\r\n      (useQueryStore as any).__selectMemo = new Map();\r\n    }\r\n    const cache = (useQueryStore as any).__selectMemo as Map<\r\n      string,\r\n      { selectRef: Function; inputRef: unknown; output: unknown }\r\n    >;\r\n\r\n    const prev = cache.get(resolvedKey);\r\n    if (prev && prev.selectRef === select && prev.inputRef === entry.data) {\r\n      selected = prev.output as R;\r\n    } else {\r\n      const out = select(entry.data as T);\r\n      cache.delete(resolvedKey);\r\n      cache.set(resolvedKey, {\r\n        selectRef: select,\r\n        inputRef: entry.data,\r\n        output: out,\r\n      });\r\n      if (selectMemoMaxEntries > 0 && cache.size > selectMemoMaxEntries) {\r\n        const firstKey = cache.keys().next().value;\r\n        if (firstKey !== undefined) cache.delete(firstKey);\r\n      }\r\n      selected = out as R;\r\n    }\r\n  }\r\n\r\n  const hasData = entry?.data !== undefined;\r\n  const error = entry?.error;\r\n  const fetchedAt = entry?.fetchedAt;\r\n  const staleTime = entry?.staleTime;\r\n  const cacheTime = entry?.cacheTime;\r\n  const refetchInterval = entry?.refetchInterval;\r\n  const tags = entry?.tags;\r\n  const retry = entry?.retry;\r\n  const entryFetcher = entry?.fetcher;\r\n  const now = Date.now();\r\n  const isStale =\r\n    !fetchedAt ||\r\n    now - fetchedAt >\r\n      (staleTime ?? DEFAULT_STALE_TIME);\r\n\r\n  useEffect(() => {\r\n    fetcherRef.current = mergedOptions.fetcher;\r\n  }, [mergedOptions.fetcher]);\r\n\r\n  useEffect(() => {\r\n    const enabled = mergedOptions.enabled ?? false;\r\n    if (!enabled) return;\r\n\r\n    const f = fetcherRef.current;\r\n    if (!f) return;\r\n\r\n    if (isFetching) return;\r\n\r\n    if (hasData && !isStale) return;\r\n    if (initialDataRef.current?.key === resolvedKey && !hasData) return;\r\n\r\n    useQueryStore\r\n      .getState()\r\n      .fetchQuery<T>(key, {\r\n        fetcher: f,\r\n        staleTime:\r\n          mergedOptions.staleTime ?? staleTime ?? DEFAULT_STALE_TIME,\r\n        cacheTime:\r\n          mergedOptions.cacheTime ?? cacheTime ?? DEFAULT_CACHE_TIME,\r\n        background: false,\r\n        refetchInterval:\r\n          mergedOptions.refetchInterval ?? refetchInterval,\r\n        tags: mergedOptions.tags ?? tags,\r\n        retry: mergedOptions.retry ?? retry,\r\n        abortOnNewFetch: mergedOptions.abortOnNewFetch ?? true,\r\n        onSuccess: mergedOptions.onSuccess,\r\n        onError: mergedOptions.onError,\r\n        onSettled: mergedOptions.onSettled,\r\n        meta: mergedOptions.meta,\r\n      })\r\n      .catch(() => {});\r\n  }, [\r\n    resolvedKey,\r\n    mergedOptions.enabled,\r\n    mergedOptions.staleTime,\r\n    mergedOptions.cacheTime,\r\n    mergedOptions.refetchInterval,\r\n    JSON.stringify(mergedOptions.tags ?? []),\r\n  ]);\r\n\r\n  const refetch = async (opts?: { background?: boolean }) => {\r\n    const state = useQueryStore.getState();\r\n    const q = state.queries[resolvedKey];\r\n    const fetcher = (q?.fetcher ?? mergedOptions.fetcher) as\r\n      | QueryFetcher<T>\r\n      | undefined;\r\n\r\n    if (mergedOptions.enabled === false) return undefined;\r\n\r\n    if (!fetcher) return undefined;\r\n\r\n    return state.fetchQuery<T>(key, {\r\n      fetcher,\r\n      staleTime: mergedOptions.staleTime ?? q.staleTime,\r\n      cacheTime: mergedOptions.cacheTime ?? q.cacheTime,\r\n      background: opts?.background ?? false,\r\n      skipStaleWhileRevalidate: true,\r\n      refetchInterval: mergedOptions.refetchInterval ?? q.refetchInterval,\r\n      tags: mergedOptions.tags ?? q.tags,\r\n      retry: mergedOptions.retry ?? q.retry,\r\n      abortOnNewFetch: mergedOptions.abortOnNewFetch ?? true,\r\n      onSuccess: mergedOptions.onSuccess,\r\n      onError: mergedOptions.onError,\r\n      onSettled: mergedOptions.onSettled,\r\n      meta: mergedOptions.meta,\r\n    });\r\n  };\r\n\r\n  if (mergedOptions.initialData !== undefined) {\r\n    if (initialDataRef.current?.key !== resolvedKey) {\r\n      const value =\r\n        typeof mergedOptions.initialData === \"function\"\r\n          ? (mergedOptions.initialData as () => T)()\r\n          : mergedOptions.initialData;\r\n      if (value !== undefined) {\r\n        initialDataRef.current = { key: resolvedKey, value };\r\n      }\r\n    }\r\n  } else if (initialDataRef.current?.key === resolvedKey) {\r\n    initialDataRef.current = null;\r\n  }\r\n\r\n  const initialDataValue =\r\n    initialDataRef.current?.key === resolvedKey\r\n      ? initialDataRef.current.value\r\n      : undefined;\r\n\r\n  useEffect(() => {\r\n    const enabled = mergedOptions.enabled ?? false;\r\n    if (!enabled) return;\r\n    if (hasData) return;\r\n    if (initialDataValue === undefined) return;\r\n    if (initialDataAppliedRef.current === resolvedKey) return;\r\n    useQueryStore.getState().setQueryData<T>(resolvedKey, initialDataValue, {\r\n      staleTime: mergedOptions.staleTime,\r\n      cacheTime: mergedOptions.cacheTime,\r\n      refetchInterval: mergedOptions.refetchInterval,\r\n      tags: mergedOptions.tags,\r\n      retry: mergedOptions.retry,\r\n      meta: mergedOptions.meta,\r\n    });\r\n    initialDataAppliedRef.current = resolvedKey;\r\n  }, [\r\n    resolvedKey,\r\n    mergedOptions.enabled,\r\n    mergedOptions.staleTime,\r\n    mergedOptions.cacheTime,\r\n    mergedOptions.refetchInterval,\r\n    JSON.stringify(mergedOptions.tags ?? []),\r\n    initialDataValue,\r\n  ]);\r\n\r\n  useEffect(() => {\r\n    if (!hasData) return;\r\n    previousDataRef.current = selected as R | undefined;\r\n    previousKeyRef.current = resolvedKey;\r\n  }, [resolvedKey, hasData, selected]);\r\n\r\n  let displayData = selected as R | undefined;\r\n  let hasDisplayData = hasData;\r\n\r\n  if (!hasData && initialDataValue !== undefined) {\r\n    displayData = select\r\n      ? select(initialDataValue)\r\n      : (initialDataValue as unknown as R);\r\n    hasDisplayData = true;\r\n  } else if (\r\n    !hasData &&\r\n    keepPreviousData &&\r\n    previousDataRef.current !== undefined &&\r\n    previousKeyRef.current !== resolvedKey\r\n  ) {\r\n    displayData = previousDataRef.current;\r\n    hasDisplayData = true;\r\n  } else if (\r\n    !hasData &&\r\n    isFetching &&\r\n    mergedOptions.placeholderData !== undefined\r\n  ) {\r\n    const placeholder =\r\n      typeof mergedOptions.placeholderData === \"function\"\r\n        ? (mergedOptions.placeholderData as (prev: R | undefined) => R)(\r\n            previousDataRef.current\r\n          )\r\n        : mergedOptions.placeholderData;\r\n    displayData = placeholder;\r\n    hasDisplayData = true;\r\n  }\r\n\r\n  useEffect(() => {\r\n    useQueryStore.getState().addObserver(key);\r\n    return () => {\r\n      useQueryStore.getState().removeObserver(key);\r\n    };\r\n  }, [resolvedKey]);\r\n\r\n  if (throwOnError && error) {\r\n    throw error;\r\n  }\r\n  if (suspense && isFetching && !hasDisplayData) {\r\n    const promise = useQueryStore.getState().inFlight[resolvedKey];\r\n    if (promise) throw promise;\r\n  }\r\n\r\n  return {\r\n    data: displayData,\r\n    error,\r\n    isLoading: isFetching && !hasDisplayData,\r\n    isFetching,\r\n    isStale,\r\n    refetch,\r\n  };\r\n}\r\n","import { useEffect, useRef } from \"react\";\r\nimport {\r\n  InfiniteData,\r\n  QueryDefaultOptions,\r\n  QueryKey,\r\n  RetryOptions,\r\n} from \"../types\";\r\nimport { DEFAULT_CACHE_TIME, DEFAULT_STALE_TIME } from \"../store/defaults\";\r\nimport { hashKey, keyToString } from \"../utils/keys\";\r\nimport { useQueryStore } from \"../store\";\r\n\r\nexport type UseInfiniteQueryOptions<TPage, TParam> = {\r\n  fetcher: (ctx: { pageParam: TParam; signal?: AbortSignal }) => Promise<TPage>;\r\n  getNextPageParam: (\r\n    lastPage: TPage,\r\n    pages: TPage[],\r\n    pageParams: TParam[]\r\n  ) => TParam | undefined;\r\n  getPreviousPageParam?: (\r\n    firstPage: TPage,\r\n    pages: TPage[],\r\n    pageParams: TParam[]\r\n  ) => TParam | undefined;\r\n  initialPageParam: TParam;\r\n  enabled?: boolean;\r\n  suspense?: boolean;\r\n  throwOnError?: boolean;\r\n  background?: boolean;\r\n  keepPreviousData?: boolean;\r\n  initialData?: InfiniteData<TPage, TParam> | (() => InfiniteData<TPage, TParam>);\r\n  placeholderData?:\r\n    | InfiniteData<TPage, TParam>\r\n    | ((prev: InfiniteData<TPage, TParam> | undefined) => InfiniteData<TPage, TParam>);\r\n  onSuccess?: (data: InfiniteData<TPage, TParam>) => void;\r\n  onError?: (error: unknown) => void;\r\n  onSettled?: (\r\n    data: InfiniteData<TPage, TParam> | undefined,\r\n    error: unknown | undefined\r\n  ) => void;\r\n  meta?: unknown;\r\n  staleTime?: number;\r\n  cacheTime?: number;\r\n  refetchInterval?: number;\r\n  tags?: string[];\r\n  retry?: RetryOptions;\r\n  abortOnNewFetch?: boolean;\r\n};\r\n\r\nexport type UseInfiniteQueryReturn<TPage, TParam> = {\r\n  data: InfiniteData<TPage, TParam> | undefined;\r\n  error: unknown;\r\n  isLoading: boolean;\r\n  isFetching: boolean;\r\n  isFetchingNextPage: boolean;\r\n  isFetchingPreviousPage: boolean;\r\n  hasNextPage: boolean;\r\n  hasPreviousPage: boolean;\r\n  fetchNextPage: () => Promise<InfiniteData<TPage, TParam> | undefined>;\r\n  fetchPreviousPage: () => Promise<InfiniteData<TPage, TParam> | undefined>;\r\n  refetch: () => Promise<InfiniteData<TPage, TParam> | undefined>;\r\n};\r\n\r\nexport function useInfiniteQuery<TPage, TParam>(\r\n  key: QueryKey,\r\n  options: UseInfiniteQueryOptions<TPage, TParam>\r\n): UseInfiniteQueryReturn<TPage, TParam> {\r\n  const resolvedKey = hashKey(key);\r\n  const config = useQueryStore.getState().config;\r\n  const defaults = (config.queryDefaults ?? []).reduce<QueryDefaultOptions>(\r\n    (acc, entry) => {\r\n      if (keyToString(key).startsWith(entry.prefix)) {\r\n        return { ...acc, ...entry.options };\r\n      }\r\n      return acc;\r\n    },\r\n    {}\r\n  );\r\n  const {\r\n    initialData: defaultInitialData,\r\n    placeholderData: defaultPlaceholderData,\r\n    ...restDefaults\r\n  } = defaults;\r\n  const mergedOptions: UseInfiniteQueryOptions<TPage, TParam> = {\r\n    ...(restDefaults as Omit<\r\n      UseInfiniteQueryOptions<TPage, TParam>,\r\n      \"initialData\" | \"placeholderData\"\r\n    >),\r\n    ...options,\r\n    retry: options.retry ?? defaults.retry,\r\n    tags: options.tags ?? defaults.tags,\r\n    refetchInterval: options.refetchInterval ?? defaults.refetchInterval,\r\n    abortOnNewFetch: options.abortOnNewFetch ?? defaults.abortOnNewFetch,\r\n    staleTime: options.staleTime ?? defaults.staleTime,\r\n    cacheTime: options.cacheTime ?? defaults.cacheTime,\r\n    initialData:\r\n      options.initialData ??\r\n      (defaultInitialData as\r\n        | InfiniteData<TPage, TParam>\r\n        | (() => InfiniteData<TPage, TParam>)\r\n        | undefined),\r\n    placeholderData:\r\n      options.placeholderData ??\r\n      (defaultPlaceholderData as\r\n        | InfiniteData<TPage, TParam>\r\n        | ((prev: InfiniteData<TPage, TParam> | undefined) => InfiniteData<TPage, TParam>)\r\n        | undefined),\r\n  };\r\n  const suspense = mergedOptions.suspense ?? config.suspense;\r\n  const throwOnError = mergedOptions.throwOnError ?? config.throwOnError;\r\n  const keepPreviousData = mergedOptions.keepPreviousData ?? false;\r\n  const previousDataRef = useRef<InfiniteData<TPage, TParam> | undefined>(\r\n    undefined\r\n  );\r\n  const previousKeyRef = useRef<string | undefined>(undefined);\r\n  const initialDataAppliedRef = useRef<string | undefined>(undefined);\r\n  const initialDataRef = useRef<{\r\n    key: string;\r\n    value: InfiniteData<TPage, TParam>;\r\n  } | null>(null);\r\n  const fetcherRef = useRef(mergedOptions.fetcher);\r\n\r\n  const entry = useQueryStore((state) => state.queries[resolvedKey]);\r\n  const isFetching = useQueryStore((state) => !!state.inFlight[resolvedKey]);\r\n  const data = entry?.data as InfiniteData<TPage, TParam> | undefined;\r\n  const error = entry?.error;\r\n  const hasData = entry?.data !== undefined;\r\n  const fetchedAt = entry?.fetchedAt;\r\n  const staleTime = entry?.staleTime;\r\n  const cacheTime = entry?.cacheTime;\r\n  const refetchInterval = entry?.refetchInterval;\r\n  const tags = entry?.tags;\r\n  const retry = entry?.retry;\r\n  const now = Date.now();\r\n  const isStale =\r\n    !fetchedAt ||\r\n    now - fetchedAt >\r\n      (staleTime ?? DEFAULT_STALE_TIME);\r\n\r\n  useEffect(() => {\r\n    fetcherRef.current = mergedOptions.fetcher;\r\n  }, [mergedOptions.fetcher]);\r\n\r\n  useEffect(() => {\r\n    const enabled = mergedOptions.enabled ?? false;\r\n    if (!enabled) return;\r\n    if (!fetcherRef.current) return;\r\n    if (isFetching) return;\r\n    if (hasData && !isStale) return;\r\n    if (initialDataRef.current?.key === resolvedKey && !hasData) return;\r\n\r\n    useQueryStore\r\n      .getState()\r\n      .fetchInfiniteQuery<TPage, TParam>(key, {\r\n        fetcher: fetcherRef.current,\r\n        pageParam: mergedOptions.initialPageParam,\r\n        direction: \"init\",\r\n        staleTime:\r\n          mergedOptions.staleTime ?? staleTime ?? DEFAULT_STALE_TIME,\r\n        cacheTime:\r\n          mergedOptions.cacheTime ?? cacheTime ?? DEFAULT_CACHE_TIME,\r\n        background: false,\r\n        refetchInterval:\r\n          mergedOptions.refetchInterval ?? refetchInterval,\r\n        tags: mergedOptions.tags ?? tags,\r\n        retry: mergedOptions.retry ?? retry,\r\n        abortOnNewFetch: mergedOptions.abortOnNewFetch ?? true,\r\n        onSuccess: mergedOptions.onSuccess,\r\n        onError: mergedOptions.onError,\r\n        onSettled: mergedOptions.onSettled,\r\n        meta: mergedOptions.meta,\r\n      })\r\n      .catch(() => {});\r\n  }, [\r\n    resolvedKey,\r\n    mergedOptions.enabled,\r\n    mergedOptions.staleTime,\r\n    mergedOptions.cacheTime,\r\n    mergedOptions.refetchInterval,\r\n    JSON.stringify(mergedOptions.tags ?? []),\r\n  ]);\r\n\r\n  if (mergedOptions.initialData !== undefined) {\r\n    if (initialDataRef.current?.key !== resolvedKey) {\r\n      const value =\r\n        typeof mergedOptions.initialData === \"function\"\r\n          ? (mergedOptions.initialData as () => InfiniteData<TPage, TParam>)()\r\n          : mergedOptions.initialData;\r\n      if (value !== undefined) {\r\n        initialDataRef.current = { key: resolvedKey, value };\r\n      }\r\n    }\r\n  } else if (initialDataRef.current?.key === resolvedKey) {\r\n    initialDataRef.current = null;\r\n  }\r\n\r\n  const initialDataValue =\r\n    initialDataRef.current?.key === resolvedKey\r\n      ? initialDataRef.current.value\r\n      : undefined;\r\n\r\n  useEffect(() => {\r\n    const enabled = mergedOptions.enabled ?? false;\r\n    if (!enabled) return;\r\n    if (hasData) return;\r\n    if (initialDataValue === undefined) return;\r\n    if (initialDataAppliedRef.current === resolvedKey) return;\r\n    useQueryStore\r\n      .getState()\r\n      .setQueryData<InfiniteData<TPage, TParam>>(resolvedKey, initialDataValue, {\r\n        staleTime: mergedOptions.staleTime,\r\n        cacheTime: mergedOptions.cacheTime,\r\n        refetchInterval: mergedOptions.refetchInterval,\r\n        tags: mergedOptions.tags,\r\n        retry: mergedOptions.retry,\r\n        meta: mergedOptions.meta,\r\n      });\r\n    initialDataAppliedRef.current = resolvedKey;\r\n  }, [\r\n    resolvedKey,\r\n    mergedOptions.enabled,\r\n    mergedOptions.staleTime,\r\n    mergedOptions.cacheTime,\r\n    mergedOptions.refetchInterval,\r\n    JSON.stringify(mergedOptions.tags ?? []),\r\n    initialDataValue,\r\n  ]);\r\n\r\n  useEffect(() => {\r\n    if (!hasData) return;\r\n    previousDataRef.current = data;\r\n    previousKeyRef.current = resolvedKey;\r\n  }, [resolvedKey, hasData, data]);\r\n\r\n  let displayData = data;\r\n  let hasDisplayData = hasData;\r\n\r\n  if (!hasData && initialDataValue !== undefined) {\r\n    displayData = initialDataValue;\r\n    hasDisplayData = true;\r\n  } else if (\r\n    !hasData &&\r\n    keepPreviousData &&\r\n    previousDataRef.current !== undefined &&\r\n    previousKeyRef.current !== resolvedKey\r\n  ) {\r\n    displayData = previousDataRef.current;\r\n    hasDisplayData = true;\r\n  } else if (\r\n    !hasData &&\r\n    isFetching &&\r\n    mergedOptions.placeholderData !== undefined\r\n  ) {\r\n    const placeholder =\r\n      typeof mergedOptions.placeholderData === \"function\"\r\n        ? (mergedOptions.placeholderData as (\r\n            prev: InfiniteData<TPage, TParam> | undefined\r\n          ) => InfiniteData<TPage, TParam>)(previousDataRef.current)\r\n        : mergedOptions.placeholderData;\r\n    displayData = placeholder;\r\n    hasDisplayData = true;\r\n  }\r\n\r\n  const hasNextPage =\r\n    !!displayData &&\r\n    mergedOptions.getNextPageParam(\r\n      displayData.pages[displayData.pages.length - 1],\r\n      displayData.pages,\r\n      displayData.pageParams\r\n    ) !== undefined;\r\n  const hasPreviousPage =\r\n    !!displayData &&\r\n    mergedOptions.getPreviousPageParam\r\n      ? mergedOptions.getPreviousPageParam(\r\n          displayData.pages[0],\r\n          displayData.pages,\r\n          displayData.pageParams\r\n        ) !== undefined\r\n      : false;\r\n\r\n  const fetchNextPage = async () => {\r\n    if (mergedOptions.enabled === false) return undefined;\r\n    const state = useQueryStore.getState();\r\n    const current = state.queries[resolvedKey]?.data as\r\n      | InfiniteData<TPage, TParam>\r\n      | undefined;\r\n    const pageParam = current\r\n      ? mergedOptions.getNextPageParam(\r\n          current.pages[current.pages.length - 1],\r\n          current.pages,\r\n          current.pageParams\r\n        )\r\n      : mergedOptions.initialPageParam;\r\n    if (pageParam === undefined) return undefined;\r\n    return state.fetchInfiniteQuery<TPage, TParam>(key, {\r\n      fetcher: fetcherRef.current,\r\n      pageParam,\r\n      direction: current ? \"forward\" : \"init\",\r\n      staleTime: mergedOptions.staleTime ?? staleTime,\r\n      cacheTime: mergedOptions.cacheTime ?? cacheTime,\r\n      background: false,\r\n      refetchInterval: mergedOptions.refetchInterval ?? refetchInterval,\r\n      tags: mergedOptions.tags ?? tags,\r\n      retry: mergedOptions.retry ?? retry,\r\n      abortOnNewFetch: mergedOptions.abortOnNewFetch ?? true,\r\n      onSuccess: mergedOptions.onSuccess,\r\n      onError: mergedOptions.onError,\r\n      onSettled: mergedOptions.onSettled,\r\n      meta: mergedOptions.meta,\r\n    });\r\n  };\r\n\r\n  const fetchPreviousPage = async () => {\r\n    if (mergedOptions.enabled === false) return undefined;\r\n    if (!mergedOptions.getPreviousPageParam) return undefined;\r\n    const state = useQueryStore.getState();\r\n    const current = state.queries[resolvedKey]?.data as\r\n      | InfiniteData<TPage, TParam>\r\n      | undefined;\r\n    if (!current) return undefined;\r\n    const pageParam = mergedOptions.getPreviousPageParam(\r\n      current.pages[0],\r\n      current.pages,\r\n      current.pageParams\r\n    );\r\n    if (pageParam === undefined) return undefined;\r\n    return state.fetchInfiniteQuery<TPage, TParam>(key, {\r\n      fetcher: fetcherRef.current,\r\n      pageParam,\r\n      direction: \"backward\",\r\n      staleTime: mergedOptions.staleTime ?? staleTime,\r\n      cacheTime: mergedOptions.cacheTime ?? cacheTime,\r\n      background: false,\r\n      refetchInterval: mergedOptions.refetchInterval ?? refetchInterval,\r\n      tags: mergedOptions.tags ?? tags,\r\n      retry: mergedOptions.retry ?? retry,\r\n      abortOnNewFetch: mergedOptions.abortOnNewFetch ?? true,\r\n      onSuccess: mergedOptions.onSuccess,\r\n      onError: mergedOptions.onError,\r\n      onSettled: mergedOptions.onSettled,\r\n      meta: mergedOptions.meta,\r\n    });\r\n  };\r\n\r\n  const refetch = async () => {\r\n    if (mergedOptions.enabled === false) return undefined;\r\n    const state = useQueryStore.getState();\r\n    const current = state.queries[resolvedKey]?.data as\r\n      | InfiniteData<TPage, TParam>\r\n      | undefined;\r\n    if (!current) return fetchNextPage();\r\n    try {\r\n      const result = await state.refetchInfiniteQuery<TPage, TParam>(key);\r\n      if (result) {\r\n        mergedOptions.onSuccess?.(result);\r\n        mergedOptions.onSettled?.(result, undefined);\r\n      }\r\n      return result;\r\n    } catch (error) {\r\n      mergedOptions.onError?.(error);\r\n      mergedOptions.onSettled?.(undefined, error);\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    useQueryStore.getState().addObserver(key);\r\n    return () => {\r\n      useQueryStore.getState().removeObserver(key);\r\n    };\r\n  }, [resolvedKey]);\r\n\r\n  if (throwOnError && error) {\r\n    throw error;\r\n  }\r\n  if (suspense && isFetching && !hasDisplayData) {\r\n    const promise = useQueryStore.getState().inFlight[resolvedKey];\r\n    if (promise) throw promise;\r\n  }\r\n\r\n  const inFlightDirection = useQueryStore\r\n    .getState()\r\n    .getInFlightDirection(resolvedKey);\r\n\r\n  return {\r\n    data: displayData,\r\n    error,\r\n    isLoading: isFetching && !hasDisplayData,\r\n    isFetching,\r\n    isFetchingNextPage:\r\n      isFetching && inFlightDirection === \"forward\",\r\n    isFetchingPreviousPage:\r\n      isFetching && inFlightDirection === \"backward\",\r\n    hasNextPage,\r\n    hasPreviousPage,\r\n    fetchNextPage,\r\n    fetchPreviousPage,\r\n    refetch,\r\n  };\r\n}\r\n","import { useCallback, useState } from \"react\";\r\nimport { MutateOptions } from \"../types\";\r\nimport { useQueryStore } from \"../store\";\r\n\r\nexport type UseMutationOptions<TVars, TResult> = Omit<\r\n  MutateOptions<TVars, TResult>,\r\n  \"variables\"\r\n> & {\r\n  onSettled?: (\r\n    result: TResult | undefined,\r\n    error: unknown | undefined,\r\n    vars: TVars\r\n  ) => void;\r\n};\r\n\r\nexport function useMutation<TVars, TResult>(\r\n  opts: UseMutationOptions<TVars, TResult>\r\n): {\r\n  mutate: (variables: TVars) => Promise<TResult>;\r\n  isLoading: boolean;\r\n  error: unknown;\r\n  data: TResult | undefined;\r\n  reset: () => void;\r\n  cancel: () => void;\r\n  status: \"idle\" | \"loading\" | \"success\" | \"error\";\r\n} {\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [error, setError] = useState<unknown>(undefined);\r\n  const [data, setData] = useState<TResult | undefined>(undefined);\r\n\r\n  const mutate = useCallback(\r\n    async (variables: TVars) => {\r\n      setIsLoading(true);\r\n      setError(undefined);\r\n\r\n      try {\r\n        const result = await useQueryStore.getState().mutate<TVars, TResult>({\r\n          ...opts,\r\n          variables,\r\n          onSuccess: (r, v) => {\r\n            opts.onSuccess?.(r, v);\r\n          },\r\n          onError: (e, v) => {\r\n            opts.onError?.(e, v);\r\n          },\r\n        });\r\n\r\n        setData(result);\r\n        opts.onSettled?.(result, undefined, variables);\r\n        return result;\r\n      } catch (e) {\r\n        setError(e);\r\n        opts.onSettled?.(undefined, e, variables);\r\n        throw e;\r\n      } finally {\r\n        setIsLoading(false);\r\n      }\r\n    },\r\n    [opts]\r\n  );\r\n\r\n  const reset = useCallback(() => {\r\n    setIsLoading(false);\r\n    setError(undefined);\r\n    setData(undefined);\r\n  }, []);\r\n\r\n  const cancel = useCallback(() => {\r\n    if (opts.mutationKey) {\r\n      useQueryStore.getState().cancelMutation(opts.mutationKey);\r\n    }\r\n  }, [opts.mutationKey]);\r\n\r\n  const status: \"idle\" | \"loading\" | \"success\" | \"error\" = isLoading\r\n    ? \"loading\"\r\n    : error\r\n      ? \"error\"\r\n      : data !== undefined\r\n        ? \"success\"\r\n        : \"idle\";\r\n\r\n  return { mutate, isLoading, error, data, reset, cancel, status };\r\n}\r\n","import { QueryFetcher, QueryKey } from \"../types\";\r\nimport {\r\n  UseInfiniteQueryOptions,\r\n  UseInfiniteQueryReturn,\r\n  useInfiniteQuery,\r\n} from \"../hooks/useInfiniteQuery\";\r\nimport { UseMutationOptions, useMutation } from \"../hooks/useMutation\";\r\nimport { UseQueryOptions, UseQueryReturn, useQuery } from \"../hooks/useQuery\";\r\n\r\nexport type { UseInfiniteQueryOptions, UseInfiniteQueryReturn } from \"../hooks/useInfiniteQuery\";\r\nexport type { UseMutationOptions } from \"../hooks/useMutation\";\r\nexport type { UseQueryOptions, UseQueryReturn } from \"../hooks/useQuery\";\r\n\r\nexport function useSimpleQuery<T, R = T>(\r\n  key: QueryKey,\r\n  fetcher: QueryFetcher<T>,\r\n  options?: Omit<UseQueryOptions<T, R>, \"fetcher\">\r\n): UseQueryReturn<T, R> {\r\n  return useQuery<T, R>(key, {\r\n    ...options,\r\n    fetcher,\r\n    enabled: options?.enabled ?? true,\r\n    keepPreviousData: options?.keepPreviousData ?? true,\r\n  });\r\n}\r\n\r\nexport function useSimpleMutation<TVars, TResult>(\r\n  mutationFn: (vars: TVars) => Promise<TResult>,\r\n  options?: Omit<UseMutationOptions<TVars, TResult>, \"mutationFn\">\r\n) {\r\n  return useMutation<TVars, TResult>({\r\n    ...options,\r\n    mutationFn,\r\n  });\r\n}\r\n\r\nexport function useSimpleInfiniteQuery<TPage, TParam = unknown>(\r\n  key: QueryKey,\r\n  fetcher: (ctx: { pageParam: TParam }) => Promise<TPage>,\r\n  options: Omit<UseInfiniteQueryOptions<TPage, TParam>, \"fetcher\">\r\n): UseInfiniteQueryReturn<TPage, TParam> {\r\n  return useInfiniteQuery<TPage, TParam>(key, {\r\n    ...options,\r\n    fetcher,\r\n    enabled: options.enabled ?? true,\r\n  });\r\n}\r\n"],"mappings":"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","names":["out","sleep","runWithRetry","runWithRetry","existing","options","entry","import_react","entry","error","import_react"]}